# C# 程序集、反射与元数据技术题汇总

## 一、程序集基础知识

### 技术题1：程序集的定义与组成

**问题：** 什么是.NET程序集？请详细描述程序集的结构和组成部分，并解释清单(manifest)在程序集中的作用。

**答案：**

程序集是.NET应用程序的基本构建单元，是逻辑相关的类型和资源的集合，形成一个功能单元。物理上，程序集通常表现为.exe或.dll文件。

**程序集的组成部分：**

1. **程序集清单(Assembly Manifest)**：包含程序集元数据，是程序集的核心组成部分，提供以下信息：
   - 程序集标识信息（名称、版本、文化、公钥令牌）
   - 文件列表（构成程序集的所有文件）
   - 类型引用映射（将类型映射到实现它们的文件）
   - 依赖程序集引用（程序集依赖的其他程序集列表）
   - 安全权限请求（程序集请求的安全权限）

2. **类型元数据**：描述程序集中定义的所有类型（类、接口、结构等）的详细信息。

3. **MSIL代码(Microsoft Intermediate Language)**：编译器生成的中间语言代码，在运行时由JIT编译器转换为本机代码。

4. **资源**：程序集可以包含嵌入式资源，如字符串、图像、图标等。

**程序集清单的作用：**

程序集清单作为程序集的"身份证"，提供CLR（公共语言运行时）加载和管理程序集所需的所有信息：

1. **唯一标识**：通过名称、版本、文化和公钥令牌唯一标识程序集
2. **版本控制**：支持并行执行不同版本的程序集
3. **依赖管理**：声明对其他程序集的依赖关系
4. **类型解析**：将类型名称映射到实现文件
5. **安全边界**：定义程序集的安全需求和信任级别

**代码示例 - 查看程序集信息：**

```csharp
using System;
using System.Reflection;

class Program
{
    static void Main()
    {
        // 获取当前执行的程序集
        Assembly currentAssembly = Assembly.GetExecutingAssembly();
        
        // 显示程序集的基本信息
        Console.WriteLine("程序集名称: " + currentAssembly.FullName);
        
        // 显示程序集的版本信息
        AssemblyName assemblyName = currentAssembly.GetName();
        Console.WriteLine("程序集版本: " + assemblyName.Version);
        
        // 显示程序集中包含的类型
        Console.WriteLine("\n程序集中的类型:");
        foreach (Type type in currentAssembly.GetTypes())
        {
            Console.WriteLine("- " + type.FullName);
        }
        
        // 显示程序集引用的其他程序集
        Console.WriteLine("\n引用的程序集:");
        foreach (AssemblyName refAssembly in currentAssembly.GetReferencedAssemblies())
        {
            Console.WriteLine("- " + refAssembly.Name + " (v" + refAssembly.Version + ")");
        }
    }
}
```

**优点分析：**
- 程序集提供了封装、版本控制和部署的单位
- 清单提供自描述能力，使程序集成为自包含的部署单元
- 支持并行版本执行，避免"DLL地狱"问题
- 提供安全边界和类型安全

**缺点分析：**
- 清单增加了文件大小
- 版本控制可能变得复杂，尤其在大型应用程序中
- 某些情况下，程序集加载和管理会带来性能开销

### 技术题2：程序集的强命名与GAC

**问题：** 什么是程序集的强命名？为什么需要强命名？请解释GAC(全局程序集缓存)的作用和如何将强命名程序集安装到GAC中。

**答案：**

**强命名程序集：**

强命名程序集是使用私钥数字签名的程序集，它确保程序集的完整性和唯一性。强命名的程序集包含四个关键要素：
1. 程序集的简单文本名称
2. 版本号（主版本.次版本.内部版本.修订号）
3. 文化信息（适用于特定语言和区域的程序集）
4. 公钥令牌（由私钥对应的公钥生成的哈希值）

**为什么需要强命名：**

1. **唯一标识**：确保在全局范围内程序集名称唯一，即使不同开发者创建同名程序集
2. **版本控制**：支持并行版本执行，允许不同版本的同一程序集共存
3. **完整性验证**：防止程序集被篡改，CLR可以验证程序集的完整性
4. **GAC部署**：只有强命名的程序集才能安装到全局程序集缓存(GAC)
5. **信任级别**：强命名表明程序集的发布者，可作为信任决策的依据

**GAC (全局程序集缓存)：**

GAC是一个机器范围的程序集缓存，为常用程序集提供集中存储位置。

**GAC的作用：**

1. **共享程序集**：多个应用程序可以共享同一程序集，节省磁盘空间和内存
2. **版本并行**：支持同一程序集的多个版本并行运行
3. **预编译优化**：存储在GAC中的程序集可以被NGEN预编译，提高加载性能
4. **安全性**：只有强命名的程序集才能安装到GAC，确保完整性

**将程序集安装到GAC：**

**方法1：使用gacutil.exe工具（开发环境）：**

```
gacutil /i MyAssembly.dll
```

移除程序集：

```
gacutil /u MyAssembly
```

**方法2：使用Windows Installer：**

```xml
<ItemGroup>
  <Reference Include="MyAssembly">
    <HintPath>path\to\MyAssembly.dll</HintPath>
    <Private>False</Private>
  </Reference>
</ItemGroup>
```

**方法3：编程方式（不推荐，仅示例）：**

```csharp
// 这种方法不推荐用于生产环境
using System.EnterpriseServices.Internal;
using System.Reflection;

// 安装到GAC
public static void InstallAssembly(string assemblyPath)
{
    Publish publish = new Publish();
    publish.GacInstall(assemblyPath);
}

// 从GAC卸载
public static void UninstallAssembly(string assemblyPath)
{
    Assembly assembly = Assembly.LoadFile(assemblyPath);
    string assemblyName = assembly.GetName().Name;
    
    Publish publish = new Publish();
    publish.GacRemove(assemblyPath);
}
```

**创建强命名程序集的步骤：**

1. 首先，生成密钥对（.snk文件）：

```
sn -k MyKeyPair.snk
```

2. 使用Visual Studio设置强命名：
   - 项目属性 → 签名 → 勾选"为程序集签名"
   - 选择密钥文件或创建新的密钥文件

3. 或者使用AssemblyInfo.cs中的特性：

```csharp
[assembly: AssemblyKeyFile("MyKeyPair.snk")]
```

4. 或者在.NET Core/.NET 5+项目中使用.csproj设置：

```xml
<PropertyGroup>
  <SignAssembly>true</SignAssembly>
  <AssemblyOriginatorKeyFile>MyKeyPair.snk</AssemblyOriginatorKeyFile>
</PropertyGroup>
```

**查看程序集是否强命名：**

```
sn -T MyAssembly.dll
```

**优点分析：**
- 提供程序集的唯一性和完整性保证
- 支持程序集的版本控制和并行执行
- 通过GAC支持程序集共享，减少磁盘和内存占用
- 提供安全验证机制，防止程序集被篡改

**缺点分析：**
- 增加了开发和部署的复杂性
- 密钥管理的责任（私钥必须安全保存）
- GAC部署需要管理员权限
- 在同一台机器上更新共享程序集可能影响多个应用程序

### 技术题3：程序集的加载与AppDomain

**问题：** 解释.NET中程序集加载的过程和AppDomain的作用。如何动态加载程序集，并讨论不同加载方法的区别和应用场景。

**答案：**

**程序集加载过程：**

当CLR需要访问程序集中的类型时，会按照以下步骤加载程序集：

1. **探测**：CLR确定程序集的完整身份（名称、版本、文化、公钥令牌）
2. **查找**：按照特定的搜索顺序查找程序集文件
   - 已加载的程序集缓存
   - GAC（如果是强命名程序集）
   - 应用程序基目录
   - 私有路径目录（如bin目录）
   - 配置文件中指定的目录（应用程序配置文件中的probing路径）
3. **加载**：将程序集文件加载到内存中
4. **验证**：对于强命名程序集，验证其数字签名
5. **安全检查**：根据当前安全策略进行权限检查
6. **类型初始化**：初始化类型系统所需的类型

**AppDomain的作用：**

AppDomain（应用程序域）是CLR中用于隔离应用程序的轻量级进程。

主要作用：
1. **隔离性**：不同AppDomain之间的状态和类型彼此隔离
2. **安全边界**：可以为每个AppDomain分配不同的安全权限
3. **程序集加载控制**：每个AppDomain有自己的程序集加载上下文
4. **应用程序卸载**：可以卸载单个AppDomain而不影响进程中的其他AppDomain
5. **故障隔离**：一个AppDomain中的故障不会影响其他AppDomain

> 注意：在.NET Core和.NET 5+中，AppDomain的部分功能被限制，许多隔离场景建议使用AssemblyLoadContext或单独的进程。

**动态加载程序集的方法：**

1. **Assembly.Load方法系列：**

```csharp
// 从强名称加载
Assembly assembly1 = Assembly.Load("MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=abcdef1234567890");

// 从AssemblyName加载
AssemblyName asmName = new AssemblyName("MyAssembly");
asmName.Version = new Version(1, 0, 0, 0);
Assembly assembly2 = Assembly.Load(asmName);

// 从字节数组加载
byte[] assemblyBytes = File.ReadAllBytes("path/to/MyAssembly.dll");
Assembly assembly3 = Assembly.Load(assemblyBytes);
```

2. **Assembly.LoadFrom：**

```csharp
// 从文件路径加载
Assembly assembly = Assembly.LoadFrom(@"C:\MyAssemblies\MyAssembly.dll");
```

3. **Assembly.LoadFile：**

```csharp
// 从完整文件路径加载，不使用标准加载上下文
Assembly assembly = Assembly.LoadFile(@"C:\MyAssemblies\MyAssembly.dll");
```

4. **AssemblyLoadContext（.NET Core/.NET 5+）：**

```csharp
using System.Runtime.Loader;

// 自定义程序集加载上下文
class MyLoadContext : AssemblyLoadContext
{
    private string _folderPath;
    
    public MyLoadContext(string folderPath) : base(isCollectible: true)
    {
        _folderPath = folderPath;
    }
    
    protected override Assembly Load(AssemblyName assemblyName)
    {
        string assemblyPath = Path.Combine(_folderPath, $"{assemblyName.Name}.dll");
        if (File.Exists(assemblyPath))
        {
            return LoadFromAssemblyPath(assemblyPath);
        }
        
        return null;
    }
}

// 使用自定义加载上下文
var loadContext = new MyLoadContext(@"C:\MyAssemblies");
Assembly assembly = loadContext.LoadFromAssemblyName(new AssemblyName("MyAssembly"));

// 使用完后可以卸载
loadContext.Unload();
```

**不同加载方法的区别：**

| 方法                        | 加载上下文                | 依赖项解析               | 主要用途                   | 注意事项                              |
| --------------------------- | ------------------------- | ------------------------ | -------------------------- | ------------------------------------- |
| Assembly.Load(AssemblyName) | 调用程序集的加载上下文    | 使用标准探测规则         | 首选方法，按强名称加载     | 需要知道完整的程序集标识              |
| Assembly.Load(byte[])       | 当前AppDomain的加载上下文 | 使用标准探测规则         | 加载内存中的程序集         | 被加载程序集的依赖项必须可用          |
| Assembly.LoadFrom(string)   | LoadFrom上下文            | 可以从原始位置加载依赖项 | 从特定路径加载程序集       | 可能导致同一程序集的多个副本被加载    |
| Assembly.LoadFile(string)   | 独立加载上下文            | 不自动解析依赖项         | 加载特定文件，忽略标准探测 | 必须手动加载所有依赖项                |
| AssemblyLoadContext         | 自定义加载上下文          | 可完全定制               | 隔离加载，支持卸载         | .NET Core/.NET 5+特有，提供更好的控制 |

**应用场景：**

1. **Assembly.Load(AssemblyName)**：
   - 加载强命名程序集
   - 当程序集位于标准探测路径中

2. **Assembly.Load(byte[])**：
   - 从数据库或网络加载程序集
   - 需要避免锁定程序集文件

3. **Assembly.LoadFrom**：
   - 加载位于非标准位置的程序集
   - 需要加载程序集及其依赖项

4. **Assembly.LoadFile**：
   - 需要加载特定文件，而不考虑标准加载规则
   - 需要对依赖项加载有完全控制

5. **AssemblyLoadContext**：
   - 插件系统，需要隔离加载和卸载插件
   - 需要支持并行加载同一程序集的不同版本
   - 需要在.NET Core/.NET 5+中实现AppDomain类似的隔离

**优点分析：**
- 动态加载提供了运行时灵活性，支持插件架构
- 按需加载可以减少启动时间和内存使用
- AppDomain提供隔离，增强安全性和稳定性
- AssemblyLoadContext在.NET Core中提供更细粒度的控制

**缺点分析：**
- 动态加载增加了复杂性和潜在的运行时错误
- 版本冲突和依赖项解析可能变得复杂
- 反射和动态加载通常比静态引用慢
- AppDomain在.NET Core中功能受限
- 需要谨慎处理内存管理，避免内存泄漏

## 二、反射基础与应用

### 技术题4：反射的基础与Type类

**问题：** 什么是反射？请详细解释Type类的作用和如何使用它获取类型信息。提供获取类型成员（字段、属性、方法等）的代码示例并分析反射的优缺点。

**答案：**

**反射的定义：**

反射是.NET框架提供的一种机制，允许在运行时检查、发现和操作类型、程序集、模块等元数据。通过反射，程序可以在运行时：
- 获取类型信息（如成员、属性、方法等）
- 动态创建类型的实例
- 动态调用类型的方法
- 动态访问和修改字段和属性
- 检查自定义特性

**Type类的作用：**

Type类是反射的核心，它表示类型的声明，如类、接口、数组、值类型或委托。Type类提供了：
- 获取类型信息的方法
- 检查类型成员（方法、属性、字段等）
- 创建类型实例
- 检查类型继承关系和实现接口
- 获取类型的自定义特性

**获取Type对象的方法：**

```csharp
// 方法1：使用typeof运算符（编译时类型）
Type type1 = typeof(string);

// 方法2：通过对象的GetType方法（运行时类型）
string s = "Hello";
Type type2 = s.GetType();

// 方法3：通过Type.GetType方法（使用类型的完全限定名）
Type type3 = Type.GetType("System.String");

// 方法4：通过Assembly获取
Assembly assembly = Assembly.GetExecutingAssembly();
Type[] types = assembly.GetTypes(); // 获取程序集中所有类型
```

**获取和使用类型成员的示例：**

```csharp
using System;
using System.Reflection;

// 示例类
public class Person
{
    // 字段
    private int _age;
    public string Name;
    
    // 属性
    public int Age
    {
        get { return _age; }
        set { _age = value > 0 ? value : 0; }
    }
    
    // 构造函数
    public Person() { }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
    
    // 方法
    public void Introduce()
    {
        Console.WriteLine($"Hi, I'm {Name}, {Age} years old.");
    }
    
    private string GetDetails()
    {
        return $"Name: {Name}, Age: {Age}";
    }
}

class Program
{
    static void Main()
    {
        // 获取Person类型
        Type personType = typeof(Person);
        
        Console.WriteLine($"类型名称: {personType.Name}");
        Console.WriteLine($"完全限定名: {personType.FullName}");
        Console.WriteLine($"命名空间: {personType.Namespace}");
        Console.WriteLine($"是类吗: {personType.IsClass}");
        Console.WriteLine($"是值类型吗: {personType.IsValueType}");
        Console.WriteLine();
        
        // 获取构造函数
        Console.WriteLine("构造函数:");
        ConstructorInfo[] constructors = personType.GetConstructors();
        foreach (var constructor in constructors)
        {
            Console.Write($"- {constructor.Name}(");
            ParameterInfo[] parameters = constructor.GetParameters();
            for (int i = 0; i < parameters.Length; i++)
            {
                Console.Write($"{parameters[i].ParameterType.Name} {parameters[i].Name}");
                if (i < parameters.Length - 1) Console.Write(", ");
            }
            Console.WriteLine(")");
        }
        Console.WriteLine();
        
        // 获取字段（包括私有字段）
        Console.WriteLine("字段:");
        FieldInfo[] fields = personType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        foreach (var field in fields)
        {
            Console.WriteLine($"- {field.FieldType.Name} {field.Name} (是私有的: {field.IsPrivate})");
        }
        Console.WriteLine();
        
        // 获取属性
        Console.WriteLine("属性:");
        PropertyInfo[] properties = personType.GetProperties();
        foreach (var property in properties)
        {
            Console.WriteLine($"- {property.PropertyType.Name} {property.Name} (可读: {property.CanRead}, 可写: {property.CanWrite})");
        }
        Console.WriteLine();
        
        // 获取方法（包括私有方法）
        Console.WriteLine("方法:");
        MethodInfo[] methods = personType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
        foreach (var method in methods)
        {
            Console.Write($"- {method.ReturnType.Name} {method.Name}(");
            ParameterInfo[] parameters = method.GetParameters();
            for (int i = 0; i < parameters.Length; i++)
            {
                Console.Write($"{parameters[i].ParameterType.Name} {parameters[i].Name}");
                if (i < parameters.Length - 1) Console.Write(", ");
            }
            Console.WriteLine($") (是私有的: {method.IsPrivate})");
        }
        Console.WriteLine();
        
        // 动态创建实例并调用方法
        Console.WriteLine("动态创建实例并调用方法:");
        
        // 使用默认构造函数创建实例
        object person1 = Activator.CreateInstance(personType);
        
        // 获取并设置属性
        PropertyInfo nameProperty = personType.GetField("Name");
        nameProperty.SetValue(person1, "John");
        
        PropertyInfo ageProperty = personType.GetProperty("Age");
        ageProperty.SetValue(person1, 30);
        
        // 调用公共方法
        MethodInfo introduceMethod = personType.GetMethod("Introduce");
        introduceMethod.Invoke(person1, null);
        
        // 调用私有方法
        MethodInfo detailsMethod = personType.GetMethod("GetDetails", BindingFlags.NonPublic | BindingFlags.Instance);
        string details = (string)detailsMethod.Invoke(person1, null);
        Console.WriteLine($"从私有方法获取的详情: {details}");
        
        // 使用带参数的构造函数创建实例
        object person2 = Activator.CreateInstance(personType, new object[] { "Jane", 25 });
        introduceMethod.Invoke(person2, null);
    }
}
```

**反射的优点：**

1. **动态行为**：允许程序在编译时不知道的类型上操作
2. **灵活性**：支持插件架构、配置驱动的应用程序和动态加载
3. **自省能力**：程序可以检查自己的结构，用于调试、序列化等
4. **元编程**：能够生成代码或修改现有类型的行为
5. **降低耦合度**：特定场景下可以减少直接依赖

**反射的缺点：**

1. **性能开销**：反射操作比直接调用慢许多倍
2. **安全风险**：可以访问私有成员，可能破坏封装
3. **缺少编译时检查**：类型错误在运行时才会被发现
4. **代码可读性降低**：反射代码往往难以理解和维护
5. **可能绕过安全机制**：如果没有适当的权限检查，可能导致安全问题

**性能影响示例：**

```csharp
using System;
using System.Diagnostics;
using System.Reflection;

class PerformanceTest
{
    public static void DirectCall()
    {
        Person person = new Person();
        person.Name = "Test";
        person.Age = 30;
        
        // 直接调用10,000,000次
        Stopwatch sw = Stopwatch.StartNew();
        for (int i = 0; i < 10_000_000; i++)
        {
            string name = person.Name;
            int age = person.Age;
        }
        sw.Stop();
        Console.WriteLine($"直接访问属性耗时: {sw.ElapsedMilliseconds}ms");
    }
    
    public static void ReflectionCall()
    {
        Person person = new Person();
        Type type = typeof(Person);
        PropertyInfo nameProperty = type.GetProperty("Name");
        PropertyInfo ageProperty = type.GetProperty("Age");
        
        // 通过反射调用10,000,000次
        Stopwatch sw = Stopwatch.StartNew();
        for (int i = 0; i < 10_000_000; i++)
        {
            string name = (string)nameProperty.GetValue(person);
            int age = (int)ageProperty.GetValue(person);
        }
        sw.Stop();
        Console.WriteLine($"反射访问属性耗时: {sw.ElapsedMilliseconds}ms");
    }
    
    public static void CachedReflectionCall()
    {
        Person person = new Person();
        Type type = typeof(Person);
        
        // 预编译获取委托（提高性能）
        var nameGetter = (Func<Person, string>)Delegate.CreateDelegate(
            typeof(Func<Person, string>), 
            type.GetProperty("Name").GetGetMethod());
            
        var ageGetter = (Func<Person, int>)Delegate.CreateDelegate(
            typeof(Func<Person, int>), 
            type.GetProperty("Age").GetGetMethod());
        
        // 通过委托调用10,000,000次
        Stopwatch sw = Stopwatch.StartNew();
        for (int i = 0; i < 10_000_000; i++)
        {
            string name = nameGetter(person);
            int age = ageGetter(person);
        }
        sw.Stop();
        Console.WriteLine($"缓存委托访问属性耗时: {sw.ElapsedMilliseconds}ms");
    }
    
    // 调用测试方法
    public static void RunTests()
    {
        DirectCall();
        ReflectionCall();
        CachedReflectionCall();
    }
}
```

**使用反射的最佳实践：**

1. **缓存反射结果**：重用Type对象和MemberInfo对象，避免重复查找
2. **使用预编译表达式**：对于频繁调用的反射操作，使用Expression Trees或动态方法生成委托
3. **限制使用范围**：只在真正需要动态行为的地方使用反射
4. **考虑替代方案**：如接口、委托、虚方法或策略模式
5. **正确处理异常**：反射操作可能抛出多种异常，确保适当捕获和处理

### 技术题5：动态创建和调用

**问题：** 如何使用反射动态创建对象并调用其方法？比较Activator.CreateInstance、构造函数反射和表达式树方法的性能差异。实现一个简单的插件系统，通过反射动态加载和使用插件。

**答案：**

**动态创建对象的方法：**

.NET中有多种方式可以动态创建对象：

1. **Activator.CreateInstance**：最简单但性能较低的方法
2. **构造函数反射**：使用ConstructorInfo.Invoke方法
3. **表达式树**：性能最好，但代码较复杂
4. **动态方法**：使用DynamicMethod和IL生成
5. **Delegate.CreateDelegate**：为方法调用创建委托

**基本示例 - 创建对象并调用方法：**

```csharp
using System;
using System.Reflection;
using System.Linq.Expressions;

// 示例类
public class Calculator
{
    public int Add(int a, int b) => a + b;
    public int Multiply(int a, int b) => a * b;
}

class Program
{
    static void Main()
    {
        // 方法1：使用Activator.CreateInstance
        Calculator calc1 = (Calculator)Activator.CreateInstance(typeof(Calculator));
        Console.WriteLine($"2 + 3 = {calc1.Add(2, 3)}");
        
        // 方法2：使用构造函数反射
        ConstructorInfo ctor = typeof(Calculator).GetConstructor(Type.EmptyTypes);
        Calculator calc2 = (Calculator)ctor.Invoke(null);
        Console.WriteLine($"4 * 5 = {calc2.Multiply(4, 5)}");
        
        // 方法3：使用表达式树
        var createExpr = Expression.New(typeof(Calculator));
        var lambdaExpr = Expression.Lambda<Func<Calculator>>(createExpr);
        Func<Calculator> factory = lambdaExpr.Compile();
        Calculator calc3 = factory();
        Console.WriteLine($"3 + 7 = {calc3.Add(3, 7)}");
        
        // 动态调用方法（三种不同方式）
        DynamicMethodCall();
    }
    
    static void DynamicMethodCall()
    {
        Type calcType = typeof(Calculator);
        object calc = Activator.CreateInstance(calcType);
        
        // 方法1：使用MethodInfo.Invoke（最简单但最慢）
        MethodInfo addMethod = calcType.GetMethod("Add");
        int result1 = (int)addMethod.Invoke(calc, new object[] { 10, 20 });
        Console.WriteLine($"10 + 20 = {result1} (通过MethodInfo.Invoke)");
        
        // 方法2：创建委托（更快）
        var addDelegate = (Func<Calculator, int, int, int>)Delegate.CreateDelegate(
            typeof(Func<Calculator, int, int, int>),
            null,
            addMethod);
            
        int result2 = addDelegate((Calculator)calc, 10, 20);
        Console.WriteLine($"10 + 20 = {result2} (通过委托)");
        
        // 方法3：使用表达式树（最快，接近直接调用）
        ParameterExpression calcParam = Expression.Parameter(typeof(Calculator), "calc");
        ParameterExpression aParam = Expression.Parameter(typeof(int), "a");
        ParameterExpression bParam = Expression.Parameter(typeof(int), "b");
        
        MethodCallExpression callExpr = Expression.Call(
            calcParam,
            addMethod,
            aParam,
            bParam);
            
        var lambdaExpr = Expression.Lambda<Func<Calculator, int, int, int>>(
            callExpr,
            calcParam,
            aParam,
            bParam);
            
        Func<Calculator, int, int, int> compiledAdd = lambdaExpr.Compile();
        int result3 = compiledAdd((Calculator)calc, 10, 20);
        Console.WriteLine($"10 + 20 = {result3} (通过表达式树)");
    }
}
```

**性能比较：**

以下代码比较了不同方法创建对象的性能：

```csharp
using System;
using System.Diagnostics;
using System.Reflection;
using System.Linq.Expressions;

class PerformanceComparison
{
    // 测试直接实例化
    public static void TestDirect(int iterations)
    {
        Stopwatch sw = Stopwatch.StartNew();
        for (int i = 0; i < iterations; i++)
        {
            Calculator calc = new Calculator();
            int result = calc.Add(i, i);
        }
        sw.Stop();
        Console.WriteLine($"直接创建和调用: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试Activator.CreateInstance
    public static void TestActivator(int iterations)
    {
        Type type = typeof(Calculator);
        MethodInfo method = type.GetMethod("Add");
        
        Stopwatch sw = Stopwatch.StartNew();
        for (int i = 0; i < iterations; i++)
        {
            object calc = Activator.CreateInstance(type);
            int result = (int)method.Invoke(calc, new object[] { i, i });
        }
        sw.Stop();
        Console.WriteLine($"Activator.CreateInstance: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试构造函数反射
    public static void TestConstructor(int iterations)
    {
        Type type = typeof(Calculator);
        ConstructorInfo ctor = type.GetConstructor(Type.EmptyTypes);
        MethodInfo method = type.GetMethod("Add");
        
        Stopwatch sw = Stopwatch.StartNew();
        for (int i = 0; i < iterations; i++)
        {
            object calc = ctor.Invoke(null);
            int result = (int)method.Invoke(calc, new object[] { i, i });
        }
        sw.Stop();
        Console.WriteLine($"构造函数反射: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试表达式树
    public static void TestExpressionTree(int iterations)
    {
        // 编译创建对象的表达式
        var createExpr = Expression.New(typeof(Calculator));
        var lambdaExpr = Expression.Lambda<Func<Calculator>>(createExpr);
        Func<Calculator> factory = lambdaExpr.Compile();
        
        // 编译调用方法的表达式
        MethodInfo addMethod = typeof(Calculator).GetMethod("Add");
        ParameterExpression calcParam = Expression.Parameter(typeof(Calculator), "calc");
        ParameterExpression aParam = Expression.Parameter(typeof(int), "a");
        ParameterExpression bParam = Expression.Parameter(typeof(int), "b");
        
        MethodCallExpression callExpr = Expression.Call(
            calcParam,
            addMethod,
            aParam,
            bParam);
            
        var callLambda = Expression.Lambda<Func<Calculator, int, int, int>>(
            callExpr,
            calcParam,
            aParam,
            bParam);
            
        Func<Calculator, int, int, int> compiledAdd = callLambda.Compile();
        
        Stopwatch sw = Stopwatch.StartNew();
        for (int i = 0; i < iterations; i++)
        {
            Calculator calc = factory();
            int result = compiledAdd(calc, i, i);
        }
        sw.Stop();
        Console.WriteLine($"表达式树: {sw.ElapsedMilliseconds}ms");
    }
    
    // 运行测试
    public static void RunTests()
    {
        int iterations = 1_000_000;
        Console.WriteLine($"执行每种方法 {iterations:N0} 次:");
        Console.WriteLine("------------------------------");
        
        TestDirect(iterations);
        TestActivator(iterations);
        TestConstructor(iterations);
        TestExpressionTree(iterations);
    }
}
```

**实现简单的插件系统：**

下面是一个简单的插件系统实现，可以动态加载和使用插件：

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

// 插件接口
public interface IPlugin
{
    string Name { get; }
    string Version { get; }
    void Execute();
}

// 插件管理器
public class PluginManager
{
    private List<IPlugin> _plugins = new List<IPlugin>();
    
    // 从目录加载插件
    public void LoadPlugins(string directory)
    {
        // 确保目录存在
        if (!Directory.Exists(directory))
        {
            Console.WriteLine($"插件目录不存在: {directory}");
            return;
        }
        
        // 获取所有DLL文件
        string[] dllFiles = Directory.GetFiles(directory, "*.dll");
        
        foreach (string dllFile in dllFiles)
        {
            try
            {
                // 加载程序集
                Assembly assembly = Assembly.LoadFrom(dllFile);
                
                // 查找实现IPlugin接口的类型
                foreach (Type type in assembly.GetTypes())
                {
                    if (typeof(IPlugin).IsAssignableFrom(type) && !type.IsInterface && !type.IsAbstract)
                    {
                        // 创建插件实例
                        IPlugin plugin = (IPlugin)Activator.CreateInstance(type);
                        _plugins.Add(plugin);
                        
                        Console.WriteLine($"已加载插件: {plugin.Name} v{plugin.Version}");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"加载插件 {dllFile} 时出错: {ex.Message}");
            }
        }
    }
    
    // 获取所有已加载的插件
    public IEnumerable<IPlugin> GetPlugins()
    {
        return _plugins;
    }
    
    // 执行特定名称的插件
    public bool ExecutePlugin(string name)
    {
        foreach (var plugin in _plugins)
        {
            if (plugin.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine($"执行插件: {plugin.Name}");
                plugin.Execute();
                return true;
            }
        }
        
        Console.WriteLine($"未找到插件: {name}");
        return false;
    }
    
    // 执行所有插件
    public void ExecuteAll()
    {
        Console.WriteLine("执行所有插件:");
        foreach (var plugin in _plugins)
        {
            Console.WriteLine($"- 正在执行 {plugin.Name}...");
            plugin.Execute();
        }
    }
}

// 主程序
class Program
{
    static void Main()
    {
        PluginManager manager = new PluginManager();
        
        // 加载插件
        string pluginDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins");
        manager.LoadPlugins(pluginDir);
        
        // 展示菜单
        bool exit = false;
        while (!exit)
        {
            Console.WriteLine("\n插件系统菜单:");
            Console.WriteLine("1. 列出所有插件");
            Console.WriteLine("2. 执行特定插件");
            Console.WriteLine("3. 执行所有插件");
            Console.WriteLine("4. 退出");
            
            Console.Write("请选择操作: ");
            string choice = Console.ReadLine();
            
            switch (choice)
            {
                case "1":
                    ListPlugins(manager);
                    break;
                case "2":
                    ExecuteSpecificPlugin(manager);
                    break;
                case "3":
                    manager.ExecuteAll();
                    break;
                case "4":
                    exit = true;
                    break;
                default:
                    Console.WriteLine("无效的选择");
                    break;
            }
        }
    }
    
    static void ListPlugins(PluginManager manager)
    {
        Console.WriteLine("\n已加载的插件:");
        int count = 0;
        foreach (var plugin in manager.GetPlugins())
        {
            Console.WriteLine($"{++count}. {plugin.Name} v{plugin.Version}");
        }
        
        if (count == 0)
        {
            Console.WriteLine("没有加载任何插件");
        }
    }
    
    static void ExecuteSpecificPlugin(PluginManager manager)
    {
        Console.Write("\n请输入要执行的插件名称: ");
        string name = Console.ReadLine();
        manager.ExecutePlugin(name);
    }
}

// 示例插件实现（放在单独的DLL中）
/*
using System;

namespace ExamplePlugin
{
    public class HelloPlugin : IPlugin
    {
        public string Name => "HelloPlugin";
        public string Version => "1.0";
        
        public void Execute()
        {
            Console.WriteLine("Hello from example plugin!");
        }
    }
    
    public class DateTimePlugin : IPlugin
    {
        public string Name => "DateTimePlugin";
        public string Version => "1.2";
        
        public void Execute()
        {
            Console.WriteLine($"Current date and time: {DateTime.Now}");
        }
    }
}
*/
```

**动态创建对象和调用方法的优缺点分析：**

**1. Activator.CreateInstance**
- **优点**：使用简单，代码简洁
- **缺点**：性能最差，每次调用都需要进行类型查找和安全检查

**2. 构造函数反射（ConstructorInfo.Invoke）**
- **优点**：直接使用特定构造函数，略快于Activator
- **缺点**：仍然比直接实例化慢得多

**3. 表达式树（Expression Trees）**
- **优点**：接近原生性能，编译后的委托几乎与直接调用一样快
- **缺点**：编写复杂，需要更多代码，首次编译有一定开销

**4. 动态方法（IL生成）**
- **优点**：高性能，可直接访问私有成员
- **缺点**：需要了解IL指令，难以编写和维护

**性能比较结果（示例）：**

对于100万次操作，不同方法的典型性能结果：
- 直接创建和调用：约20-30ms
- Activator.CreateInstance：约800-1000ms
- 构造函数反射：约700-900ms
- 表达式树：约50-70ms（首次编译后）

**使用反射创建对象的最佳实践：**

1. **选择正确的方法**：
   - 一次性或低频操作：使用Activator.CreateInstance
   - 高频操作：使用表达式树或动态方法

2. **缓存反射结果**：
   - 缓存Type、ConstructorInfo和MethodInfo对象
   - 缓存编译后的表达式树委托

3. **考虑替代方案**：
   - 工厂方法模式
   - 依赖注入容器
   - 对象池

4. **处理异常**：
   - 捕获创建过程中可能的异常
   - 记录详细错误信息
   - 提供有意义的反馈

### 技术题6：反射中的性能优化

**问题：** 反射操作通常性能较低，请详细说明优化反射性能的方法，并提供代码示例。比较直接反射、缓存反射、表达式树和动态方法等不同方式的性能差异。如何在需要反射功能的同时最大限度地减少性能损失？

**答案：**

**反射性能优化策略：**

反射虽然功能强大，但其性能开销是一个主要缺点。以下是几种提高反射性能的方法：

1. **缓存反射对象**：重用Type、MethodInfo、PropertyInfo等对象
2. **使用委托**：将反射调用转换为委托调用
3. **使用表达式树**：编译为强类型委托
4. **使用动态方法和IL生成**：直接生成IL代码
5. **使用Dynamic语言运行时(DLR)**：在.NET 4.0+中使用dynamic关键字
6. **限制反射使用范围**：只在必要时使用反射

**反射性能优化代码示例：**

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;

public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    
    public string GetFullName()
    {
        return $"{FirstName} {LastName}";
    }
}

class ReflectionPerformance
{
    private static readonly int Iterations = 10_000_000;
    
    static void Main()
    {
        // 创建测试对象
        var person = new Person { FirstName = "John", LastName = "Doe" };
        
        // 运行不同方法的性能测试
        Console.WriteLine($"执行每种方法 {Iterations:N0} 次:\n");
        
        // 直接访问
        DirectAccess(person);
        
        // 直接反射（不缓存）
        DirectReflection(person);
        
        // 缓存反射对象
        CachedReflection(person);
        
        // 使用委托
        DelegateMethod(person);
        
        // 使用表达式树
        ExpressionTreeMethod(person);
        
        // 使用动态方法
        DynamicMethodIL(person);
        
        // 使用dynamic关键字
        DynamicKeyword(person);
        
        Console.WriteLine("\n属性设置测试:\n");
        
        // 测试设置属性值
        DirectPropertySet(person);
        ReflectionPropertySet(person);
        DelegatePropertySet(person);
        ExpressionPropertySet(person);
        
        Console.WriteLine("\n方法调用测试:\n");
        
        // 测试方法调用
        DirectMethodCall(person);
        ReflectionMethodCall(person);
        DelegateMethodCall(person);
        ExpressionMethodCall(person);
    }
    
    // 1. 直接访问（基准测试）
    static void DirectAccess(Person person)
    {
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string firstName = person.FirstName;
        }
        
        sw.Stop();
        Console.WriteLine($"直接访问: {sw.ElapsedMilliseconds}ms");
    }
    
    // 2. 直接反射（每次查找）
    static void DirectReflection(Person person)
    {
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            PropertyInfo prop = typeof(Person).GetProperty("FirstName");
            string firstName = (string)prop.GetValue(person);
        }
        
        sw.Stop();
        Console.WriteLine($"直接反射: {sw.ElapsedMilliseconds}ms");
    }
    
    // 3. 缓存反射对象
    static void CachedReflection(Person person)
    {
        PropertyInfo prop = typeof(Person).GetProperty("FirstName");
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string firstName = (string)prop.GetValue(person);
        }
        
        sw.Stop();
        Console.WriteLine($"缓存反射: {sw.ElapsedMilliseconds}ms");
    }
    
    // 4. 使用委托
    static void DelegateMethod(Person person)
    {
        PropertyInfo prop = typeof(Person).GetProperty("FirstName");
        Func<Person, string> getter = (Func<Person, string>)Delegate.CreateDelegate(
            typeof(Func<Person, string>),
            null,
            prop.GetGetMethod());
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string firstName = getter(person);
        }
        
        sw.Stop();
        Console.WriteLine($"委托方法: {sw.ElapsedMilliseconds}ms");
    }
    
    // 5. 使用表达式树
    static void ExpressionTreeMethod(Person person)
    {
        // 编译获取属性的表达式树
        ParameterExpression param = Expression.Parameter(typeof(Person), "p");
        MemberExpression property = Expression.Property(param, "FirstName");
        LambdaExpression lambda = Expression.Lambda(property, param);
        Func<Person, string> getter = (Func<Person, string>)lambda.Compile();
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string firstName = getter(person);
        }
        
        sw.Stop();
        Console.WriteLine($"表达式树: {sw.ElapsedMilliseconds}ms");
    }
    
    // 6. 使用动态方法和IL生成
    static void DynamicMethodIL(Person person)
    {
        // 创建动态方法
        var method = new DynamicMethod(
            "GetFirstName",
            typeof(string),
            new[] { typeof(Person) },
            typeof(Person).Module);
            
        // 获取IL生成器
        ILGenerator il = method.GetILGenerator();
        
        // 生成IL代码
        il.Emit(OpCodes.Ldarg_0); // 加载第一个参数（Person对象）
        il.Emit(OpCodes.Callvirt, typeof(Person).GetProperty("FirstName").GetGetMethod()); // 调用getter方法
        il.Emit(OpCodes.Ret); // 返回结果
        
        // 创建委托
        var getter = (Func<Person, string>)method.CreateDelegate(typeof(Func<Person, string>));
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string firstName = getter(person);
        }
        
        sw.Stop();
        Console.WriteLine($"动态方法IL: {sw.ElapsedMilliseconds}ms");
    }
    
    // 7. 使用dynamic关键字
    static void DynamicKeyword(Person person)
    {
        dynamic dynamicPerson = person;
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string firstName = dynamicPerson.FirstName;
        }
        
        sw.Stop();
        Console.WriteLine($"Dynamic关键字: {sw.ElapsedMilliseconds}ms");
    }
    
    // 属性设置测试
    
    // 直接设置属性
    static void DirectPropertySet(Person person)
    {
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            person.FirstName = "Jane";
        }
        
        sw.Stop();
        Console.WriteLine($"直接设置属性: {sw.ElapsedMilliseconds}ms");
    }
    
    // 反射设置属性
    static void ReflectionPropertySet(Person person)
    {
        PropertyInfo prop = typeof(Person).GetProperty("FirstName");
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            prop.SetValue(person, "Jane");
        }
        
        sw.Stop();
        Console.WriteLine($"反射设置属性: {sw.ElapsedMilliseconds}ms");
    }
    
    // 委托设置属性
    static void DelegatePropertySet(Person person)
    {
        PropertyInfo prop = typeof(Person).GetProperty("FirstName");
        Action<Person, string> setter = (Action<Person, string>)Delegate.CreateDelegate(
            typeof(Action<Person, string>),
            null,
            prop.GetSetMethod());
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            setter(person, "Jane");
        }
        
        sw.Stop();
        Console.WriteLine($"委托设置属性: {sw.ElapsedMilliseconds}ms");
    }
    
    // 表达式树设置属性
    static void ExpressionPropertySet(Person person)
    {
        // 编译设置属性的表达式树
        ParameterExpression instanceParam = Expression.Parameter(typeof(Person), "instance");
        ParameterExpression valueParam = Expression.Parameter(typeof(string), "value");
        MemberExpression propertyRef = Expression.Property(instanceParam, "FirstName");
        BinaryExpression assignExpr = Expression.Assign(propertyRef, valueParam);
        
        var lambda = Expression.Lambda<Action<Person, string>>(
            assignExpr,
            instanceParam,
            valueParam);
            
        Action<Person, string> setter = lambda.Compile();
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            setter(person, "Jane");
        }
        
        sw.Stop();
        Console.WriteLine($"表达式树设置属性: {sw.ElapsedMilliseconds}ms");
    }
    
    // 方法调用测试
    
    // 直接调用方法
    static void DirectMethodCall(Person person)
    {
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string fullName = person.GetFullName();
        }
        
        sw.Stop();
        Console.WriteLine($"直接调用方法: {sw.ElapsedMilliseconds}ms");
    }
    
    // 反射调用方法
    static void ReflectionMethodCall(Person person)
    {
        MethodInfo method = typeof(Person).GetMethod("GetFullName");
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string fullName = (string)method.Invoke(person, null);
        }
        
        sw.Stop();
        Console.WriteLine($"反射调用方法: {sw.ElapsedMilliseconds}ms");
    }
    
    // 委托调用方法
    static void DelegateMethodCall(Person person)
    {
        MethodInfo method = typeof(Person).GetMethod("GetFullName");
        Func<Person, string> func = (Func<Person, string>)Delegate.CreateDelegate(
            typeof(Func<Person, string>),
            null,
            method);
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string fullName = func(person);
        }
        
        sw.Stop();
        Console.WriteLine($"委托调用方法: {sw.ElapsedMilliseconds}ms");
    }
    
    // 表达式树调用方法
    static void ExpressionMethodCall(Person person)
    {
        MethodInfo method = typeof(Person).GetMethod("GetFullName");
        
        ParameterExpression param = Expression.Parameter(typeof(Person), "p");
        MethodCallExpression methodCall = Expression.Call(param, method);
        LambdaExpression lambda = Expression.Lambda(methodCall, param);
        Func<Person, string> func = (Func<Person, string>)lambda.Compile();
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < Iterations; i++)
        {
            string fullName = func(person);
        }
        
        sw.Stop();
        Console.WriteLine($"表达式树调用方法: {sw.ElapsedMilliseconds}ms");
    }
}
```

**性能比较结果（示例）：**

以下是在典型系统上运行上述代码的近似结果（10,000,000次操作）：

**属性访问：**
- 直接访问：约10-20ms
- 直接反射：约8000-10000ms
- 缓存反射：约2000-3000ms
- 委托方法：约50-80ms
- 表达式树：约30-60ms
- 动态方法IL：约20-40ms
- Dynamic关键字：约500-700ms

**属性设置：**
- 直接设置属性：约10-20ms
- 反射设置属性：约2500-3500ms
- 委托设置属性：约50-80ms
- 表达式树设置属性：约30-60ms

**方法调用：**
- 直接调用方法：约20-30ms
- 反射调用方法：约2000-3000ms
- 委托调用方法：约30-50ms
- 表达式树调用方法：约30-60ms

**反射缓存工具类示例：**

以下是一个反射缓存工具类，可用于高效地获取和设置属性值以及调用方法：

```csharp
using System;
using System.Collections.Concurrent;
using System.Linq.Expressions;
using System.Reflection;

/// <summary>
/// 提供高效反射操作的缓存工具类
/// </summary>
public static class ReflectionCache
{
    // 属性getter缓存
    private static readonly ConcurrentDictionary<PropertyKey, Delegate> PropertyGetters 
        = new ConcurrentDictionary<PropertyKey, Delegate>();
        
    // 属性setter缓存
    private static readonly ConcurrentDictionary<PropertyKey, Delegate> PropertySetters 
        = new ConcurrentDictionary<PropertyKey, Delegate>();
        
    // 方法调用缓存
    private static readonly ConcurrentDictionary<MethodKey, Delegate> MethodCalls 
        = new ConcurrentDictionary<MethodKey, Delegate>();
    
    /// <summary>
    /// 获取指定对象的属性值
    /// </summary>
    public static object GetPropertyValue(object obj, string propertyName)
    {
        if (obj == null) throw new ArgumentNullException(nameof(obj));
        if (string.IsNullOrEmpty(propertyName)) throw new ArgumentNullException(nameof(propertyName));
        
        Type type = obj.GetType();
        var key = new PropertyKey(type, propertyName);
        
        // 尝试从缓存获取委托
        if (!PropertyGetters.TryGetValue(key, out Delegate getter))
        {
            // 创建委托并添加到缓存
            PropertyInfo property = type.GetProperty(propertyName);
            if (property == null) 
                throw new ArgumentException($"Property {propertyName} not found on type {type.Name}");
                
            getter = CreatePropertyGetter(property);
            PropertyGetters[key] = getter;
        }
        
        // 调用委托
        return getter.DynamicInvoke(obj);
    }
    
    /// <summary>
    /// 获取强类型的属性值
    /// </summary>
    public static T GetPropertyValue<T>(object obj, string propertyName)
    {
        return (T)GetPropertyValue(obj, propertyName);
    }
    
    /// <summary>
    /// 设置指定对象的属性值
    /// </summary>
    public static void SetPropertyValue(object obj, string propertyName, object value)
    {
        if (obj == null) throw new ArgumentNullException(nameof(obj));
        if (string.IsNullOrEmpty(propertyName)) throw new ArgumentNullException(nameof(propertyName));
        
        Type type = obj.GetType();
        var key = new PropertyKey(type, propertyName);
        
        // 尝试从缓存获取委托
        if (!PropertySetters.TryGetValue(key, out Delegate setter))
        {
            // 创建委托并添加到缓存
            PropertyInfo property = type.GetProperty(propertyName);
            if (property == null) 
                throw new ArgumentException($"Property {propertyName} not found on type {type.Name}");
                
            setter = CreatePropertySetter(property);
            PropertySetters[key] = setter;
        }
        
        // 调用委托
        setter.DynamicInvoke(obj, value);
    }
    
    /// <summary>
    /// 调用指定对象的方法
    /// </summary>
    public static object InvokeMethod(object obj, string methodName, params object[] parameters)
    {
        if (obj == null) throw new ArgumentNullException(nameof(obj));
        if (string.IsNullOrEmpty(methodName)) throw new ArgumentNullException(nameof(methodName));
        
        Type type = obj.GetType();
        Type[] parameterTypes = parameters?.Select(p => p?.GetType() ?? typeof(object)).ToArray() ?? Type.EmptyTypes;
        var key = new MethodKey(type, methodName, parameterTypes);
        
        // 尝试从缓存获取委托
        if (!MethodCalls.TryGetValue(key, out Delegate methodCall))
        {
            // 创建委托并添加到缓存
            MethodInfo method = type.GetMethod(methodName, parameterTypes);
            if (method == null) 
                throw new ArgumentException($"Method {methodName} with specified parameters not found on type {type.Name}");
                
            methodCall = CreateMethodCall(method);
            MethodCalls[key] = methodCall;
        }
        
        // 准备参数（第一个参数是对象实例）
        object[] args = new object[parameters?.Length + 1 ?? 1];
        args[0] = obj;
        if (parameters != null)
        {
            Array.Copy(parameters, 0, args, 1, parameters.Length);
        }
        
        // 调用委托
        return methodCall.DynamicInvoke(args);
    }
    
    /// <summary>
    /// 调用指定对象的方法并返回强类型结果
    /// </summary>
    public static T InvokeMethod<T>(object obj, string methodName, params object[] parameters)
    {
        return (T)InvokeMethod(obj, methodName, parameters);
    }
    
    // 创建属性getter的委托
    private static Delegate CreatePropertyGetter(PropertyInfo property)
    {
        // 创建参数表达式
        ParameterExpression instance = Expression.Parameter(property.DeclaringType, "instance");
        
        // 创建属性访问表达式
        MemberExpression propertyAccess = Expression.Property(instance, property);
        
        // 创建lambda表达式
        Type delegateType = typeof(Func<,>).MakeGenericType(property.DeclaringType, property.PropertyType);
        LambdaExpression lambda = Expression.Lambda(delegateType, propertyAccess, instance);
        
        // 编译并返回委托
        return lambda.Compile();
    }
    
    // 创建属性setter的委托
    private static Delegate CreatePropertySetter(PropertyInfo property)
    {
        // 创建参数表达式
        ParameterExpression instance = Expression.Parameter(property.DeclaringType, "instance");
        ParameterExpression value = Expression.Parameter(property.PropertyType, "value");
        
        // 创建属性访问表达式
        MemberExpression propertyAccess = Expression.Property(instance, property);
        
        // 创建赋值表达式
        BinaryExpression assignExpression = Expression.Assign(propertyAccess, value);
        
        // 创建lambda表达式
        Type delegateType = typeof(Action<,>).MakeGenericType(property.DeclaringType, property.PropertyType);
        LambdaExpression lambda = Expression.Lambda(delegateType, assignExpression, instance, value);
        
        // 编译并返回委托
        return lambda.Compile();
    }
    
    // 创建方法调用的委托
    private static Delegate CreateMethodCall(MethodInfo method)
    {
        // 获取参数类型
        Type[] parameterTypes = method.GetParameters().Select(p => p.ParameterType).ToArray();
        
        // 创建参数表达式列表
        ParameterExpression instance = Expression.Parameter(method.DeclaringType, "instance");
        ParameterExpression[] parameters = parameterTypes
            .Select((type, index) => Expression.Parameter(type, $"param{index}"))
            .ToArray();
        
        // 创建方法调用表达式
        MethodCallExpression call = Expression.Call(instance, method, parameters);
        
        // 创建参数列表（实例 + 方法参数）
        ParameterExpression[] lambdaParameters = new ParameterExpression[parameters.Length + 1];
        lambdaParameters[0] = instance;
        Array.Copy(parameters, 0, lambdaParameters, 1, parameters.Length);
        
        // 创建委托类型
        Type[] delegateParamTypes = new Type[lambdaParameters.Length];
        for (int i = 0; i < lambdaParameters.Length; i++)
        {
            delegateParamTypes[i] = lambdaParameters[i].Type;
        }
        
        Type delegateType;
        if (method.ReturnType == typeof(void))
        {
            delegateType = Expression.GetActionType(delegateParamTypes);
            
            // 创建lambda表达式
            LambdaExpression lambda = Expression.Lambda(delegateType, call, lambdaParameters);
            return lambda.Compile();
        }
        else
        {
            Type[] funcParamTypes = new Type[delegateParamTypes.Length + 1];
            Array.Copy(delegateParamTypes, funcParamTypes, delegateParamTypes.Length);
            funcParamTypes[funcParamTypes.Length - 1] = method.ReturnType;
            
            delegateType = Expression.GetFuncType(funcParamTypes);
            
            // 创建lambda表达式
            LambdaExpression lambda = Expression.Lambda(delegateType, call, lambdaParameters);
            return lambda.Compile();
        }
    }
    
    // 属性缓存键
    private struct PropertyKey : IEquatable<PropertyKey>
    {
        public Type Type { get; }
        public string PropertyName { get; }
        
        public PropertyKey(Type type, string propertyName)
        {
            Type = type;
            PropertyName = propertyName;
        }
        
        public bool Equals(PropertyKey other)
        {
            return Type == other.Type && PropertyName == other.PropertyName;
        }
        
        public override bool Equals(object obj)
        {
            if (obj is PropertyKey key)
                return Equals(key);
            return false;
        }
        
        public override int GetHashCode()
        {
            return (Type?.GetHashCode() ?? 0) ^ (PropertyName?.GetHashCode() ?? 0);
        }
    }
    
    // 方法缓存键
    private struct MethodKey : IEquatable<MethodKey>
    {
        public Type Type { get; }
        public string MethodName { get; }
        public Type[] ParameterTypes { get; }
        
        public MethodKey(Type type, string methodName, Type[] parameterTypes)
        {
            Type = type;
            MethodName = methodName;
            ParameterTypes = parameterTypes;
        }
        
        public bool Equals(MethodKey other)
        {
            if (Type != other.Type || MethodName != other.MethodName)
                return false;
                
            if (ParameterTypes.Length != other.ParameterTypes.Length)
                return false;
                
            for (int i = 0; i < ParameterTypes.Length; i++)
            {
                if (ParameterTypes[i] != other.ParameterTypes[i])
                    return false;
            }
            
            return true;
        }
        
        public override bool Equals(object obj)
        {
            if (obj is MethodKey key)
                return Equals(key);
            return false;
        }
        
        public override int GetHashCode()
        {
            int hash = (Type?.GetHashCode() ?? 0) ^ (MethodName?.GetHashCode() ?? 0);
            
            if (ParameterTypes != null)
            {
                for (int i = 0; i < ParameterTypes.Length; i++)
                {
                    hash ^= ParameterTypes[i]?.GetHashCode() ?? 0;
                }
            }
            
            return hash;
        }
    }
}
```

**使用反射缓存工具类的例子：**

```csharp
// 使用ReflectionCache工具类
public void ReflectionCacheExample()
{
    var person = new Person { FirstName = "John", LastName = "Doe" };
    
    // 获取属性值
    string firstName = ReflectionCache.GetPropertyValue<string>(person, "FirstName");
    Console.WriteLine($"FirstName: {firstName}");
    
    // 设置属性值
    ReflectionCache.SetPropertyValue(person, "FirstName", "Jane");
    Console.WriteLine($"Updated FirstName: {person.FirstName}");
    
    // 调用方法
    string fullName = ReflectionCache.InvokeMethod<string>(person, "GetFullName");
    Console.WriteLine($"Full Name: {fullName}");
}
```

**反射性能优化的最佳实践：**

1. **最小化反射使用**：
   - 只在必要时使用反射
   - 考虑使用替代设计模式（如工厂、策略或委托）

2. **缓存反射结果**：
   - 缓存类型、成员和方法信息
   - 使用ConcurrentDictionary实现线程安全的缓存

3. **使用委托代替直接反射**：
   - 将反射调用转换为委托
   - 预编译表达式树
   - 创建专用缓存工具类

4. **使用工具库**：
   - FastMember
   - Fasterflect
   - Reflection.Emit增强库

5. **慎用Dynamic**：
   - dynamic关键字虽然简化代码，但性能不如优化的反射

6. **适当的粒度**：
   - 对频繁调用的操作进行优化
   - 平衡代码复杂性和性能

7. **限制动态行为范围**：
   - 将反射隔离在特定组件中
   - 为动态操作创建静态包装

8. **考虑IL生成**：
   - 对于极端性能要求的场景，使用IL生成
   - 使用DynamicMethod进行高效调用

9. **性能监控**：
   - 对反射操作进行基准测试
   - 识别和优化热点路径

**优点分析：**
- 通过缓存和编译委托，可以将反射性能提高到接近直接调用的水平
- 保留了反射的动态特性和灵活性
- 表达式树提供了类型安全和良好的性能
- 封装的反射缓存API简化了使用

**缺点分析：**
- 增加了代码复杂性
- 首次编译表达式树有一定开销
- 缓存增加了内存使用
- IL生成需要更专业的知识
- 仍有一定的性能开销，不如直接调用

## 三、元数据与自定义特性

### 技术题7：元数据基础与应用

**问题：** 什么是.NET中的元数据？请详细解释它的作用和应用场景。描述如何使用反射读取和处理元数据信息，并提供一个实际案例。

**答案：**

**元数据的定义：**

元数据是描述数据的数据，在.NET中，元数据是对程序集、类型、成员和其他程序实体的结构化描述。它存储在程序集内部，作为一种自描述机制，使CLR能够了解程序的结构和行为。

**元数据的组成：**

1. **类型定义**：类、接口、结构、枚举等的完整描述
2. **成员定义**：字段、属性、方法、事件等的签名和访问修饰符
3. **特性信息**：应用于各种元素的自定义特性(Attributes)
4. **程序集信息**：版本、文化、公钥等
5. **资源信息**：嵌入的资源文件
6. **安全信息**：权限设置和请求
7. **引用信息**：对其他程序集的引用

**元数据的作用：**

1. **类型安全**：CLR使用元数据验证类型安全性
2. **内存布局**：指导CLR如何在内存中布局对象
3. **序列化**：提供序列化/反序列化所需的信息
4. **反射**：支持在运行时检查和操作类型
5. **互操作**：启用与非托管代码的交互
6. **代码生成**：支持动态代码生成和即时(JIT)编译
7. **工具支持**：为开发工具、调试器提供信息

**元数据的应用场景：**

1. **反射和动态编程**：运行时发现和调用类型和成员
2. **序列化和数据绑定**：自动将对象转换为其他格式或绑定到UI
3. **依赖注入**：识别需要注入的依赖项
4. **ORM(对象关系映射)**：将类映射到数据库表
5. **代码生成工具**：根据元数据生成代码
6. **文档生成**：从代码和注释生成文档
7. **验证和AOP(面向方面编程)**：在运行时检查和增强行为

**使用反射读取元数据的示例：**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

class MetadataExplorer
{
    public static void ExploreAssembly(Assembly assembly)
    {
        Console.WriteLine($"程序集: {assembly.FullName}");
        Console.WriteLine("-------------------------------");
        
        // 程序集级别的元数据
        Console.WriteLine("程序集元数据:");
        Console.WriteLine($"- 名称: {assembly.GetName().Name}");
        Console.WriteLine($"- 版本: {assembly.GetName().Version}");
        Console.WriteLine($"- 文化: {assembly.GetName().CultureInfo.Name}");
        
        // 自定义特性
        Console.WriteLine("\n程序集特性:");
        foreach (var attribute in assembly.GetCustomAttributes())
        {
            Console.WriteLine($"- {attribute.GetType().Name}");
        }
        
        // 引用的程序集
        Console.WriteLine("\n引用的程序集:");
        foreach (var reference in assembly.GetReferencedAssemblies())
        {
            Console.WriteLine($"- {reference.Name} (v{reference.Version})");
        }
        
        // 导出的类型
        Console.WriteLine("\n导出的类型:");
        foreach (var type in assembly.GetExportedTypes())
        {
            Console.WriteLine($"\n类型: {type.FullName}");
            Console.WriteLine($"- 是类: {type.IsClass}");
            Console.WriteLine($"- 是接口: {type.IsInterface}");
            Console.WriteLine($"- 是抽象的: {type.IsAbstract}");
            Console.WriteLine($"- 是密封的: {type.IsSealed}");
            Console.WriteLine($"- 是泛型: {type.IsGenericType}");
            
            // 基类和实现的接口
            if (type.BaseType != null && type.BaseType != typeof(object))
            {
                Console.WriteLine($"- 基类: {type.BaseType.Name}");
            }
            
            if (type.GetInterfaces().Length > 0)
            {
                Console.WriteLine("- 实现的接口: " + 
                    string.Join(", ", type.GetInterfaces().Select(i => i.Name)));
            }
            
            // 类型的特性
            var typeAttributes = type.GetCustomAttributes();
            if (typeAttributes.Any())
            {
                Console.WriteLine("- 特性: " + 
                    string.Join(", ", typeAttributes.Select(a => a.GetType().Name)));
            }
            
            // 成员
            Console.WriteLine("- 成员:");
            
            // 字段
            foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | 
                                                BindingFlags.Static | BindingFlags.Instance))
            {
                Console.WriteLine($"  字段: {field.Name} ({GetAccessModifier(field)} {field.FieldType.Name})");
                
                foreach (var attr in field.GetCustomAttributes())
                {
                    Console.WriteLine($"    特性: {attr.GetType().Name}");
                }
            }
            
            // 属性
            foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | 
                                                       BindingFlags.Static | BindingFlags.Instance))
            {
                string accessors = "";
                if (property.CanRead) accessors += "get ";
                if (property.CanWrite) accessors += "set";
                
                Console.WriteLine($"  属性: {property.Name} ({property.PropertyType.Name}) [{accessors}]");
                
                foreach (var attr in property.GetCustomAttributes())
                {
                    Console.WriteLine($"    特性: {attr.GetType().Name}");
                }
            }
            
            // 方法
            foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | 
                                                  BindingFlags.Static | BindingFlags.Instance | 
                                                  BindingFlags.DeclaredOnly))
            {
                StringBuilder methodInfo = new StringBuilder();
                methodInfo.Append($"  方法: {GetAccessModifier(method)} ");
                
                if (method.IsStatic) methodInfo.Append("static ");
                if (method.IsVirtual) methodInfo.Append("virtual ");
                if (method.IsAbstract) methodInfo.Append("abstract ");
                if (method.IsGenericMethod) methodInfo.Append("generic ");
                
                methodInfo.Append($"{method.ReturnType.Name} {method.Name}(");
                
                var parameters = method.GetParameters();
                for (int i = 0; i < parameters.Length; i++)
                {
                    var param = parameters[i];
                    methodInfo.Append($"{param.ParameterType.Name} {param.Name}");
                    
                    if (param.IsOptional)
                        methodInfo.Append(" = default");
                        
                    if (i < parameters.Length - 1)
                        methodInfo.Append(", ");
                }
                methodInfo.Append(")");
                
                Console.WriteLine(methodInfo.ToString());
                
                foreach (var attr in method.GetCustomAttributes())
                {
                    Console.WriteLine($"    特性: {attr.GetType().Name}");
                }
            }
        }
    }
    
    private static string GetAccessModifier(FieldInfo field)
    {
        if (field.IsPublic) return "public";
        if (field.IsPrivate) return "private";
        if (field.IsFamily) return "protected";
        if (field.IsAssembly) return "internal";
        if (field.IsFamilyOrAssembly) return "protected internal";
        return "unknown";
    }
    
    private static string GetAccessModifier(MethodInfo method)
    {
        if (method.IsPublic) return "public";
        if (method.IsPrivate) return "private";
        if (method.IsFamily) return "protected";
        if (method.IsAssembly) return "internal";
        if (method.IsFamilyOrAssembly) return "protected internal";
        return "unknown";
    }
}

// 使用元数据浏览器
class Program
{
    static void Main()
    {
        // 浏览当前程序集
        MetadataExplorer.ExploreAssembly(Assembly.GetExecutingAssembly());
        
        // 浏览系统程序集
        MetadataExplorer.ExploreAssembly(typeof(string).Assembly);
    }
}
```

**实际案例 - 使用元数据的简单ORM框架：**

```csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using System.Text;

// 特性定义
[AttributeUsage(AttributeTargets.Class)]
public class TableAttribute : Attribute
{
    public string TableName { get; }
    
    public TableAttribute(string tableName)
    {
        TableName = tableName;
    }
}

[AttributeUsage(AttributeTargets.Property)]
public class ColumnAttribute : Attribute
{
    public string ColumnName { get; }
    
    public ColumnAttribute(string columnName)
    {
        ColumnName = columnName;
    }
}

[AttributeUsage(AttributeTargets.Property)]
public class PrimaryKeyAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Property)]
public class AutoIncrementAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Property)]
public class NotMappedAttribute : Attribute
{
}

// 简单ORM框架
public class SimpleORM
{
    private readonly string _connectionString;
    
    public SimpleORM(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    // 根据ID查询对象
    public T GetById<T>(object id) where T : new()
    {
        Type type = typeof(T);
        string tableName = GetTableName(type);
        string primaryKeyColumn = GetPrimaryKeyColumnName(type);
        
        if (string.IsNullOrEmpty(primaryKeyColumn))
            throw new InvalidOperationException($"No primary key defined for type {type.Name}");
        
        string query = $"SELECT * FROM {tableName} WHERE {primaryKeyColumn} = @Id";
        
        using (SqlConnection connection = new SqlConnection(_connectionString))
        using (SqlCommand command = new SqlCommand(query, connection))
        {
            command.Parameters.AddWithValue("@Id", id);
            connection.Open();
            
            using (SqlDataReader reader = command.ExecuteReader())
            {
                if (reader.Read())
                {
                    return MapToObject<T>(reader);
                }
            }
        }
        
        return default;
    }
    
    // 保存对象（插入或更新）
    public void Save<T>(T entity) where T : new()
    {
        Type type = typeof(T);
        string tableName = GetTableName(type);
        string primaryKeyColumn = GetPrimaryKeyColumnName(type);
        PropertyInfo primaryKeyProperty = GetPrimaryKeyProperty(type);
        
        if (primaryKeyProperty == null)
            throw new InvalidOperationException($"No primary key defined for type {type.Name}");
        
        object primaryKeyValue = primaryKeyProperty.GetValue(entity);
        bool isAutoIncrement = primaryKeyProperty.GetCustomAttribute<AutoIncrementAttribute>() != null;
        
        // 决定是插入还是更新
        if (primaryKeyValue == null || 
            (primaryKeyValue is int intValue && intValue == 0) ||
            string.IsNullOrEmpty(primaryKeyValue.ToString()))
        {
            // 执行插入
            InsertEntity(entity, type, tableName, primaryKeyProperty, isAutoIncrement);
        }
        else
        {
            // 执行更新
            UpdateEntity(entity, type, tableName, primaryKeyColumn, primaryKeyValue);
        }
    }
    
    // 删除对象
    public void Delete<T>(T entity) where T : new()
    {
        Type type = typeof(T);
        string tableName = GetTableName(type);
        string primaryKeyColumn = GetPrimaryKeyColumnName(type);
        PropertyInfo primaryKeyProperty = GetPrimaryKeyProperty(type);
        
        if (primaryKeyProperty == null)
            throw new InvalidOperationException($"No primary key defined for type {type.Name}");
        
        object primaryKeyValue = primaryKeyProperty.GetValue(entity);
        
        if (primaryKeyValue == null)
            throw new InvalidOperationException("Cannot delete entity with null primary key");
        
        string query = $"DELETE FROM {tableName} WHERE {primaryKeyColumn} = @Id";
        
        using (SqlConnection connection = new SqlConnection(_connectionString))
        using (SqlCommand command = new SqlCommand(query, connection))
        {
            command.Parameters.AddWithValue("@Id", primaryKeyValue);
            connection.Open();
            command.ExecuteNonQuery();
        }
    }
    
    // 查询所有对象
    public List<T> GetAll<T>() where T : new()
    {
        Type type = typeof(T);
        string tableName = GetTableName(type);
        
        string query = $"SELECT * FROM {tableName}";
        List<T> results = new List<T>();
        
        using (SqlConnection connection = new SqlConnection(_connectionString))
        using (SqlCommand command = new SqlCommand(query, connection))
        {
            connection.Open();
            
            using (SqlDataReader reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    T entity = MapToObject<T>(reader);
                    results.Add(entity);
                }
            }
        }
        
        return results;
    }
    
    // 根据查询获取对象
    public List<T> Query<T>(string whereClause, Dictionary<string, object> parameters) where T : new()
    {
        Type type = typeof(T);
        string tableName = GetTableName(type);
        
        string query = $"SELECT * FROM {tableName}";
        if (!string.IsNullOrEmpty(whereClause))
        {
            query += $" WHERE {whereClause}";
        }
        
        List<T> results = new List<T>();
        
        using (SqlConnection connection = new SqlConnection(_connectionString))
        using (SqlCommand command = new SqlCommand(query, connection))
        {
            if (parameters != null)
            {
                foreach (var param in parameters)
                {
                    command.Parameters.AddWithValue($"@{param.Key}", param.Value ?? DBNull.Value);
                }
            }
            
            connection.Open();
            
            using (SqlDataReader reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    T entity = MapToObject<T>(reader);
                    results.Add(entity);
                }
            }
        }
        
        return results;
    }
    
    // 将数据行映射到对象
    private T MapToObject<T>(SqlDataReader reader) where T : new()
    {
        T entity = new T();
        Type type = typeof(T);
        
        foreach (PropertyInfo property in type.GetProperties())
        {
            // 跳过不映射的属性
            if (property.GetCustomAttribute<NotMappedAttribute>() != null)
                continue;
                
            // 获取列名
            string columnName = GetColumnName(property);
            
            // 检查数据表中是否存在此列
            try
            {
                int ordinal = reader.GetOrdinal(columnName);
                
                // 不处理DBNull值
                if (!reader.IsDBNull(ordinal))
                {
                    object value = reader.GetValue(ordinal);
                    
                    // 转换类型
                    if (value is decimal && property.PropertyType == typeof(double))
                    {
                        value = Convert.ToDouble(value);
                    }
                    else if (property.PropertyType.IsEnum)
                    {
                        value = Enum.ToObject(property.PropertyType, value);
                    }
                    
                    property.SetValue(entity, value);
                }
            }
            catch (IndexOutOfRangeException)
            {
                // 列不存在，跳过
                continue;
            }
        }
        
        return entity;
    }
    
    // 插入实体
    private void InsertEntity<T>(T entity, Type type, string tableName, PropertyInfo primaryKeyProperty, bool isAutoIncrement)
    {
        StringBuilder columnNames = new StringBuilder();
        StringBuilder parameterNames = new StringBuilder();
        List<PropertyInfo> mappedProperties = new List<PropertyInfo>();
        
        foreach (PropertyInfo property in type.GetProperties())
        {
            // 跳过不映射的属性
            if (property.GetCustomAttribute<NotMappedAttribute>() != null)
                continue;
                
            // 跳过自增主键
            if (property == primaryKeyProperty && isAutoIncrement)
                continue;
                
            mappedProperties.Add(property);
            
            if (columnNames.Length > 0)
            {
                columnNames.Append(", ");
                parameterNames.Append(", ");
            }
            
            string columnName = GetColumnName(property);
            columnNames.Append(columnName);
            parameterNames.Append($"@{property.Name}");
        }
        
        string query = $"INSERT INTO {tableName} ({columnNames}) VALUES ({parameterNames})";
        
        // 如果是自增主键，获取新ID
        if (isAutoIncrement)
        {
            query += "; SELECT SCOPE_IDENTITY();";
        }
        
        using (SqlConnection connection = new SqlConnection(_connectionString))
        using (SqlCommand command = new SqlCommand(query, connection))
        {
            // 添加参数
            foreach (PropertyInfo property in mappedProperties)
            {
                object value = property.GetValue(entity) ?? DBNull.Value;
                command.Parameters.AddWithValue($"@{property.Name}", value);
            }
            
            connection.Open();
            
            if (isAutoIncrement)
            {
                // 获取新ID并设置到实体
                object newId = command.ExecuteScalar();
                if (newId != null && newId != DBNull.Value)
                {
                    // 转换ID类型
                    if (primaryKeyProperty.PropertyType == typeof(int))
                        primaryKeyProperty.SetValue(entity, Convert.ToInt32(newId));
                    else if (primaryKeyProperty.PropertyType == typeof(long))
                        primaryKeyProperty.SetValue(entity, Convert.ToInt64(newId));
                    else
                        primaryKeyProperty.SetValue(entity, newId);
                }
            }
            else
            {
                command.ExecuteNonQuery();
            }
        }
    }
    
    // 更新实体
    private void UpdateEntity<T>(T entity, Type type, string tableName, string primaryKeyColumn, object primaryKeyValue)
    {
        StringBuilder setClause = new StringBuilder();
        List<PropertyInfo> mappedProperties = new List<PropertyInfo>();
        
        foreach (PropertyInfo property in type.GetProperties())
        {
            // 跳过不映射和主键属性
            if (property.GetCustomAttribute<NotMappedAttribute>() != null ||
                property.GetCustomAttribute<PrimaryKeyAttribute>() != null)
                continue;
                
            if (setClause.Length > 0)
                setClause.Append(", ");
                
            string columnName = GetColumnName(property);
            setClause.Append($"{columnName} = @{property.Name}");
            
            mappedProperties.Add(property);
        }
        
        string query = $"UPDATE {tableName} SET {setClause} WHERE {primaryKeyColumn} = @Id";
        
        using (SqlConnection connection = new SqlConnection(_connectionString))
        using (SqlCommand command = new SqlCommand(query, connection))
        {
            // 添加参数
            foreach (PropertyInfo property in mappedProperties)
            {
                object value = property.GetValue(entity) ?? DBNull.Value;
                command.Parameters.AddWithValue($"@{property.Name}", value);
            }
            
            command.Parameters.AddWithValue("@Id", primaryKeyValue);
            
            connection.Open();
            command.ExecuteNonQuery();
        }
    }
    
    // 获取表名
    private string GetTableName(Type type)
    {
        // 查找表特性
        TableAttribute tableAttr = type.GetCustomAttribute<TableAttribute>();
        
        // 如果有特性，使用特性定义的表名
        if (tableAttr != null)
            return tableAttr.TableName;
            
        // 否则使用类名
        return type.Name;
    }
    
    // 获取列名
    private string GetColumnName(PropertyInfo property)
    {
        // 查找列特性
        ColumnAttribute columnAttr = property.GetCustomAttribute<ColumnAttribute>();
        
        // 如果有特性，使用特性定义的列名
        if (columnAttr != null)
            return columnAttr.ColumnName;
            
        // 否则使用属性名
        return property.Name;
    }
    
    // 获取主键列名
    private string GetPrimaryKeyColumnName(Type type)
    {
        // 查找带有主键特性的属性
        PropertyInfo primaryKeyProperty = GetPrimaryKeyProperty(type);
        
        if (primaryKeyProperty != null)
            return GetColumnName(primaryKeyProperty);
            
        return null;
    }
    
    // 获取主键属性
    private PropertyInfo GetPrimaryKeyProperty(Type type)
    {
        // 查找带有主键特性的属性
        foreach (PropertyInfo property in type.GetProperties())
        {
            if (property.GetCustomAttribute<PrimaryKeyAttribute>() != null)
                return property;
        }
        
        // 默认查找名为"Id"的属性
        PropertyInfo idProperty = type.GetProperty("Id");
        if (idProperty != null)
            return idProperty;
            
        return null;
    }
}

// 使用示例 - 定义实体类
[Table("Customers")]
public class Customer
{
    [PrimaryKey]
    [AutoIncrement]
    [Column("CustomerId")]
    public int Id { get; set; }
    
    [Column("FirstName")]
    public string FirstName { get; set; }
    
    [Column("LastName")]
    public string LastName { get; set; }
    
    public string Email { get; set; }
    
    public DateTime DateOfBirth { get; set; }
    
    [NotMapped]
    public int Age
    {
        get
        {
            return DateTime.Today.Year - DateOfBirth.Year - 
                (DateTime.Today < DateOfBirth.AddYears(DateTime.Today.Year - DateOfBirth.Year) ? 1 : 0);
        }
    }
    
    [NotMapped]
    public string FullName => $"{FirstName} {LastName}";
}

// 使用ORM框架
class Program
{
    static void Main()
    {
        // 创建ORM实例
        string connectionString = "Server=localhost;Database=TestDB;Trusted_Connection=True;";
        var orm = new SimpleORM(connectionString);
        
        // 创建新客户
        var customer = new Customer
        {
            FirstName = "John",
            LastName = "Doe",
            Email = "john.doe@example.com",
            DateOfBirth = new DateTime(1980, 1, 1)
        };
        
        // 保存到数据库
        orm.Save(customer);
        Console.WriteLine($"Customer saved with ID: {customer.Id}");
        
        // 查询客户
        var retrievedCustomer = orm.GetById<Customer>(customer.Id);
        Console.WriteLine($"Retrieved: {retrievedCustomer.FullName}, Email: {retrievedCustomer.Email}");
        
        // 更新客户
        retrievedCustomer.Email = "john.updated@example.com";
        orm.Save(retrievedCustomer);
        
        // 查询所有客户
        var allCustomers = orm.GetAll<Customer>();
        Console.WriteLine($"Total customers: {allCustomers.Count}");
        
        // 条件查询
        var parameters = new Dictionary<string, object>
        {
            { "FirstName", "John" }
        };
        var johnCustomers = orm.Query<Customer>("FirstName = @FirstName", parameters);
        Console.WriteLine($"Customers named John: {johnCustomers.Count}");
        
        // 删除客户
        orm.Delete(customer);
        Console.WriteLine("Customer deleted");
    }
}
```

**元数据和反射在实际应用中的优缺点：**

**优点：**

1. **灵活性**：允许在运行时自省和操作类型，实现动态行为
2. **减少代码重复**：通过元数据驱动的框架减少样板代码
3. **自动化**：简化映射、序列化、验证等常见任务
4. **配置驱动**：支持声明式编程和配置驱动的架构
5. **元编程能力**：扩展语言能力，实现领域特定语言(DSL)

**缺点：**

1. **性能开销**：频繁的元数据访问和反射操作会影响性能
2. **类型安全性降低**：编译时检查被绕过，可能导致运行时错误
3. **可读性和可维护性**：过度使用元数据和反射可能使代码难以理解
4. **调试难度增加**：动态行为通常更难追踪和调试
5. **序列化陷阱**：特性和元数据可能与实际行为不一致

**最佳实践：**

1. **适度使用**：只在真正需要动态行为时使用元数据和反射
2. **缓存结果**：避免重复查询相同的元数据
3. **提供静态包装**：为动态行为提供静态包装，增强安全性
4. **全面测试**：彻底测试基于元数据和反射的代码
5. **考虑性能影响**：在性能关键路径上谨慎使用

### 技术题8：自定义特性(Attributes)

**问题：** 详细解释C#中自定义特性(Attributes)的作用和使用方法。设计一个基于特性的验证框架，包括必填、长度限制、正则表达式、数值范围等验证功能，并提供一个使用示例。

**答案：**

**自定义特性的定义：**

自定义特性(Custom Attributes)是一种声明式编程机制，允许开发者将元数据添加到代码元素（如类、方法、属性等）上。特性本身不影响代码行为，但可以在运行时通过反射检索和使用，通常用于配置、验证、文档化等目的。

**自定义特性的基本用法：**

1. **定义特性类**：创建一个继承自`System.Attribute`的类
2. **控制特性应用位置**：使用`AttributeUsageAttribute`指定可应用的代码元素
3. **定义特性参数**：通过构造函数和属性声明特性参数
4. **应用特性**：使用`[AttributeName]`语法将特性应用到代码元素上
5. **检索特性**：使用反射获取应用的特性

**特性与反射的结合使用：**

```csharp
// 定义一个简单的自定义特性
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false)]
public class DescriptionAttribute : Attribute
{
    public string Description { get; }
    
    public DescriptionAttribute(string description)
    {
        Description = description;
    }
}

// 应用特性
[Description("这是一个示例类")]
public class ExampleClass
{
    [Description("这个方法做一些重要的事情")]
    public void DoSomething()
    {
        Console.WriteLine("Doing something...");
    }
}

// 使用反射读取特性
public static void DisplayDescriptions()
{
    Type type = typeof(ExampleClass);
    
    // 获取类上的特性
    DescriptionAttribute classAttr = (DescriptionAttribute)Attribute.GetCustomAttribute(
        type, typeof(DescriptionAttribute));
        
    if (classAttr != null)
    {
        Console.WriteLine($"类描述: {classAttr.Description}");
    }
    
    // 获取方法上的特性
    MethodInfo method = type.GetMethod("DoSomething");
    DescriptionAttribute methodAttr = (DescriptionAttribute)Attribute.GetCustomAttribute(
        method, typeof(DescriptionAttribute));
        
    if (methodAttr != null)
    {
        Console.WriteLine($"方法描述: {methodAttr.Description}");
    }
}
```

**自定义特性的作用：**

1. **配置和元数据**：提供配置信息和额外元数据
2. **代码生成**：指导代码生成工具
3. **运行时行为控制**：影响程序的运行时行为
4. **文档化**：增强代码文档
5. **框架支持**：提供与框架的集成点

**基于特性的验证框架设计：**

下面实现一个完整的验证框架，支持多种常见验证规则：

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;

// 基本验证特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public abstract class ValidationAttribute : Attribute
{
    public string ErrorMessage { get; set; }
    
    // 验证方法
    public abstract bool IsValid(object value);
    
    // 获取错误消息
    public virtual string GetErrorMessage(string propertyName)
    {
        if (!string.IsNullOrEmpty(ErrorMessage))
            return ErrorMessage;
            
        return $"Property {propertyName} validation failed.";
    }
}

// 必填字段特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class RequiredAttribute : ValidationAttribute
{
    public RequiredAttribute()
    {
        ErrorMessage = "{0} is required.";
    }
    
    public override bool IsValid(object value)
    {
        // 检查值是否为null或空字符串
        if (value == null)
            return false;
            
        if (value is string stringValue)
            return !string.IsNullOrWhiteSpace(stringValue);
            
        return true;
    }
    
    public override string GetErrorMessage(string propertyName)
    {
        return string.Format(ErrorMessage, propertyName);
    }
}

// 字符串长度特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class StringLengthAttribute : ValidationAttribute
{
    public int MinLength { get; set; } = 0;
    public int MaxLength { get; set; }
    
    public StringLengthAttribute(int maxLength)
    {
        MaxLength = maxLength;
        ErrorMessage = "{0} must be between {1} and {2} characters.";
    }
    
    public override bool IsValid(object value)
    {
        if (value == null)
            return MinLength == 0; // 如果值为null，只有当最小长度为0时才有效
            
        if (value is string stringValue)
        {
            int length = stringValue.Length;
            return length >= MinLength && length <= MaxLength;
        }
        
        return false;
    }
    
    public override string GetErrorMessage(string propertyName)
    {
        return string.Format(ErrorMessage, propertyName, MinLength, MaxLength);
    }
}

// 正则表达式特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class RegularExpressionAttribute : ValidationAttribute
{
    private readonly Regex _regex;
    
    public string Pattern { get; }
    
    public RegularExpressionAttribute(string pattern)
    {
        Pattern = pattern;
        _regex = new Regex(pattern, RegexOptions.Compiled);
        ErrorMessage = "{0} does not match the required pattern.";
    }
    
    public override bool IsValid(object value)
    {
        if (value == null)
            return true;
            
        if (value is string stringValue)
            return _regex.IsMatch(stringValue);
            
        return false;
    }
    
    public override string GetErrorMessage(string propertyName)
    {
        return string.Format(ErrorMessage, propertyName);
    }
}

// 范围特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class RangeAttribute : ValidationAttribute
{
    public object Minimum { get; }
    public object Maximum { get; }
    public Type OperandType { get; }
    
    public RangeAttribute(int minimum, int maximum)
        : this(minimum, maximum, typeof(int))
    {
    }
    
    public RangeAttribute(double minimum, double maximum)
        : this(minimum, maximum, typeof(double))
    {
    }
    
    public RangeAttribute(object minimum, object maximum, Type operandType)
    {
        Minimum = minimum;
        Maximum = maximum;
        OperandType = operandType;
        ErrorMessage = "{0} must be between {1} and {2}.";
    }
    
    public override bool IsValid(object value)
    {
        if (value == null)
            return true;
            
        if (OperandType == typeof(int))
        {
            if (int.TryParse(value.ToString(), out int intValue))
            {
                return intValue >= (int)Minimum && intValue <= (int)Maximum;
            }
        }
        else if (OperandType == typeof(double))
        {
            if (double.TryParse(value.ToString(), out double doubleValue))
            {
                return doubleValue >= (double)Minimum && doubleValue <= (double)Maximum;
            }
        }
        else if (OperandType == typeof(DateTime))
        {
            if (value is DateTime dateValue)
            {
                return dateValue >= (DateTime)Minimum && dateValue <= (DateTime)Maximum;
            }
        }
        
        return false;
    }
    
    public override string GetErrorMessage(string propertyName)
    {
        return string.Format(ErrorMessage, propertyName, Minimum, Maximum);
    }
}

// 电子邮件特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class EmailAttribute : RegularExpressionAttribute
{
    private const string EmailPattern = @"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$";
    
    public EmailAttribute()
        : base(EmailPattern)
    {
        ErrorMessage = "{0} is not a valid email address.";
    }
}

// 比较特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
public class CompareAttribute : ValidationAttribute
{
    public string OtherProperty { get; }
    
    public CompareAttribute(string otherProperty)
    {
        OtherProperty = otherProperty;
        ErrorMessage = "{0} must match {1}.";
    }
    
    public override bool IsValid(object value)
    {
        return true; // 实际验证在ValidateObject方法中完成
    }
    
    public override string GetErrorMessage(string propertyName)
    {
        return string.Format(ErrorMessage, propertyName, OtherProperty);
    }
}

// 自定义验证特性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class CustomValidationAttribute : ValidationAttribute
{
    public Type ValidatorType { get; }
    public string MethodName { get; }
    
    public CustomValidationAttribute(Type validatorType, string methodName)
    {
        ValidatorType = validatorType;
        MethodName = methodName;
    }
    
    public override bool IsValid(object value)
    {
        // 获取验证方法
        MethodInfo method = ValidatorType.GetMethod(MethodName, 
            BindingFlags.Public | BindingFlags.Static);
            
        if (method == null)
            throw new InvalidOperationException($"Validation method {MethodName} not found in {ValidatorType.Name}");
            
        // 调用验证方法
        return (bool)method.Invoke(null, new[] { value });
    }
}

// 创建包含验证逻辑的标记接口
public interface IValidatableObject
{
    IEnumerable<ValidationError> Validate();
}

// 验证错误类
public class ValidationError
{
    public string PropertyName { get; set; }
    public string ErrorMessage { get; set; }
    
    public ValidationError(string propertyName, string errorMessage)
    {
        PropertyName = propertyName;
        ErrorMessage = errorMessage;
    }
    
    public override string ToString()
    {
        return $"{PropertyName}: {ErrorMessage}";
    }
}

// 验证结果类
public class ValidationResult
{
    public bool IsValid => Errors.Count == 0;
    public List<ValidationError> Errors { get; } = new List<ValidationError>();
    
    public void AddError(string propertyName, string errorMessage)
    {
        Errors.Add(new ValidationError(propertyName, errorMessage));
    }
    
    public override string ToString()
    {
        if (IsValid)
            return "Validation succeeded.";
            
        return "Validation failed with the following errors:\n" + 
               string.Join("\n", Errors.Select(e => e.ToString()));
    }
}

// 主验证器类
public static class Validator
{
    // 验证单个对象
    public static ValidationResult Validate(object obj)
    {
        if (obj == null)
            throw new ArgumentNullException(nameof(obj));
            
        var result = new ValidationResult();
        
        // 获取对象的类型
        Type type = obj.GetType();
        
        // 处理所有带有验证特性的属性
        foreach (PropertyInfo property in type.GetProperties())
        {
            string propertyName = property.Name;
            object value = property.GetValue(obj);
            
            // 获取应用于属性的所有验证特性
            var validationAttributes = property.GetCustomAttributes<ValidationAttribute>();
            
            foreach (var attribute in validationAttributes)
            {
                // 对于比较特性，需要特殊处理
                if (attribute is CompareAttribute compareAttr)
                {
                    // 获取要比较的另一个属性
                    PropertyInfo otherProperty = type.GetProperty(compareAttr.OtherProperty);
                    if (otherProperty == null)
                    {
                        result.AddError(propertyName, 
                            $"Comparison property {compareAttr.OtherProperty} not found.");
                        continue;
                    }
                    
                    object otherValue = otherProperty.GetValue(obj);
                    
                    // 比较两个值
                    bool isEqual = value == null ? otherValue == null : value.Equals(otherValue);
                    
                    if (!isEqual)
                    {
                        result.AddError(propertyName, 
                            compareAttr.GetErrorMessage(propertyName).Replace("{1}", compareAttr.OtherProperty));
                    }
                }
                else if (!attribute.IsValid(value))
                {
                    // 添加验证错误
                    result.AddError(propertyName, attribute.GetErrorMessage(propertyName));
                }
            }
        }
        
        // 处理IValidatableObject接口
        if (obj is IValidatableObject validatable)
        {
            foreach (var error in validatable.Validate())
            {
                result.AddError(error.PropertyName, error.ErrorMessage);
            }
        }
        
        return result;
    }
    
    // 验证对象并抛出异常
    public static void ValidateAndThrow(object obj)
    {
        ValidationResult result = Validate(obj);
        
        if (!result.IsValid)
        {
            throw new ValidationException(result.ToString());
        }
    }
    
    // 泛型验证方法
    public static ValidationResult Validate<T>(T obj)
    {
        return Validate((object)obj);
    }
}

// 验证异常
public class ValidationException : Exception
{
    public ValidationException(string message) : base(message)
    {
    }
}

// 自定义验证器
public static class CustomValidators
{
    // 验证密码强度
    public static bool IsStrongPassword(string password)
    {
        if (string.IsNullOrEmpty(password))
            return false;
            
        // 密码规则：至少8个字符，包含大小写字母、数字和特殊字符
        return password.Length >= 8 &&
               password.Any(char.IsUpper) &&
               password.Any(char.IsLower) &&
               password.Any(char.IsDigit) &&
               password.Any(c => !char.IsLetterOrDigit(c));
    }
}

// 示例用户类
public class User : IValidatableObject
{
    [Required(ErrorMessage = "Username is required.")]
    [StringLength(50, MinLength = 3, ErrorMessage = "Username must be between {1} and {2} characters.")]
    [RegularExpression(@"^[a-zA-Z0-9_]+$", ErrorMessage = "Username can only contain letters, numbers and underscore.")]
    public string Username { get; set; }
    
    [Required]
    [Email]
    public string Email { get; set; }
    
    [Required]
    [StringLength(100, MinLength = 8)]
    [CustomValidation(typeof(CustomValidators), "IsStrongPassword")]
    public string Password { get; set; }
    
    [Required]
    [Compare("Password", ErrorMessage = "Passwords do not match.")]
    public string ConfirmPassword { get; set; }
    
    [Required]
    [StringLength(100)]
    public string FullName { get; set; }
    
    [Range(18, 120, ErrorMessage = "Age must be between {1} and {2}.")]
    public int Age { get; set; }
    
    // 自定义验证逻辑
    public IEnumerable<ValidationError> Validate()
    {
        // 添加无法通过特性表达的验证规则
        if (!string.IsNullOrEmpty(Username) && !string.IsNullOrEmpty(Password) && 
            Password.Contains(Username))
        {
            yield return new ValidationError("Password", "Password should not contain username.");
        }
        
        if (!string.IsNullOrEmpty(Email) && Email.StartsWith("admin"))
        {
            yield return new ValidationError("Email", "Email should not start with 'admin'.");
        }
    }
}

// 验证框架使用示例
class Program
{
    static void Main()
    {
        // 创建包含错误的用户对象
        var user = new User
        {
            Username = "j", // 太短
            Email = "not-an-email", // 无效的邮箱
            Password = "123", // 密码太弱
            ConfirmPassword = "1234", // 密码不匹配
            FullName = "John Doe",
            Age = 15 // 太年轻
        };
        
        // 验证用户
        ValidationResult result = Validator.Validate(user);
        
        Console.WriteLine(result.ToString());
        Console.WriteLine();
        
        // 创建有效的用户对象
        var validUser = new User
        {
            Username = "john_doe",
            Email = "john.doe@example.com",
            Password = "P@ssw0rd123!",
            ConfirmPassword = "P@ssw0rd123!",
            FullName = "John Doe",
            Age = 25
        };
        
        // 验证有效用户
        ValidationResult validResult = Validator.Validate(validUser);
        
        Console.WriteLine(validResult.ToString());
        
        // 演示验证并抛出异常
        try
        {
            Validator.ValidateAndThrow(user);
        }
        catch (ValidationException ex)
        {
            Console.WriteLine($"Validation exception: {ex.Message}");
        }
    }
}
```

**自定义特性验证框架的优缺点：**

**优点：**

1. **声明式验证**：通过特性直接在模型中定义验证规则，代码清晰
2. **集中式逻辑**：验证逻辑集中在特性类中，便于维护
3. **可扩展性**：容易添加新的验证规则
4. **自描述**：模型类本身就包含验证规则，增强了自文档性
5. **框架集成**：可以与其他框架（如ASP.NET MVC）集成
6. **可测试性**：验证逻辑可以单独测试

**缺点：**

1. **性能开销**：使用反射获取特性会带来性能开销
2. **灵活性有限**：复杂的验证规则可能难以通过特性表达
3. **调试难度**：验证失败的原因可能不够直观
4. **循环依赖风险**：特性之间可能存在依赖关系
5. **可见性问题**：验证规则分散在多个属性上，可能不易查看全局规则

**实际应用建议：**

1. **有选择地使用特性**：简单验证使用特性，复杂验证考虑其他方法
2. **缓存反射结果**：减少性能开销
3. **结合多种验证方式**：特性验证与业务规则验证相结合
4. **提供清晰的错误消息**：帮助用户理解验证失败的原因
5. **考虑国际化**：错误消息支持多语言

### 技术题9：动态代码生成

**问题：** 使用System.Reflection.Emit命名空间实现动态代码生成，创建一个简单的类型并在运行时使用它。比较动态代码生成与传统反射的性能差异，并讨论使用场景。

**答案：**

**动态代码生成简介：**

动态代码生成是一种在运行时创建和编译新类型的技术。在.NET中，主要通过`System.Reflection.Emit`命名空间提供的API来实现，它允许开发者在运行时生成MSIL代码，创建新的类型、方法、属性等，并立即使用它们。

**Reflection.Emit主要组件：**

1. **AssemblyBuilder**：用于创建动态程序集
2. **ModuleBuilder**：在程序集中创建模块
3. **TypeBuilder**：定义新的类型（类、接口等）
4. **MethodBuilder**：定义类型的方法
5. **PropertyBuilder**：定义类型的属性
6. **FieldBuilder**：定义类型的字段
7. **ILGenerator**：生成MSIL指令

**使用Reflection.Emit创建动态类型的示例：**

```csharp
using System;
using System.Reflection;
using System.Reflection.Emit;

class DynamicTypeGenerator
{
    // 创建一个具有属性和方法的动态类型
    public static Type CreatePersonType()
    {
        // 创建程序集名称
        AssemblyName assemblyName = new AssemblyName("DynamicAssembly");
        
        // 创建动态程序集（只在内存中）
        AssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(
            assemblyName, AssemblyBuilderAccess.Run);
            
        // 创建模块
        ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule("DynamicModule");
        
        // 创建类型（类）
        TypeBuilder typeBuilder = moduleBuilder.DefineType(
            "Person", TypeAttributes.Public | TypeAttributes.Class);
            
        // 定义字段
        FieldBuilder nameField = typeBuilder.DefineField(
            "_name", typeof(string), FieldAttributes.Private);
            
        FieldBuilder ageField = typeBuilder.DefineField(
            "_age", typeof(int), FieldAttributes.Private);
        
        // 定义Name属性
        PropertyBuilder nameProperty = typeBuilder.DefineProperty(
            "Name", PropertyAttributes.None, typeof(string), null);
            
        // 创建Name属性的get方法
        MethodBuilder getNameMethod = typeBuilder.DefineMethod(
            "get_Name",
            MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
            typeof(string),
            Type.EmptyTypes);
            
        // 生成get_Name方法的IL代码
        ILGenerator getNameIL = getNameMethod.GetILGenerator();
        getNameIL.Emit(OpCodes.Ldarg_0); // 加载this
        getNameIL.Emit(OpCodes.Ldfld, nameField); // 加载_name字段
        getNameIL.Emit(OpCodes.Ret); // 返回
        
        // 创建Name属性的set方法
        MethodBuilder setNameMethod = typeBuilder.DefineMethod(
            "set_Name",
            MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
            null,
            new[] { typeof(string) });
            
        // 生成set_Name方法的IL代码
        ILGenerator setNameIL = setNameMethod.GetILGenerator();
        setNameIL.Emit(OpCodes.Ldarg_0); // 加载this
        setNameIL.Emit(OpCodes.Ldarg_1); // 加载参数值
        setNameIL.Emit(OpCodes.Stfld, nameField); // 存储到_name字段
        setNameIL.Emit(OpCodes.Ret); // 返回
        
        // 将get和set方法关联到Name属性
        nameProperty.SetGetMethod(getNameMethod);
        nameProperty.SetSetMethod(setNameMethod);
        
        // 定义Age属性
        PropertyBuilder ageProperty = typeBuilder.DefineProperty(
            "Age", PropertyAttributes.None, typeof(int), null);
            
        // 创建Age属性的get方法
        MethodBuilder getAgeMethod = typeBuilder.DefineMethod(
            "get_Age",
            MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
            typeof(int),
            Type.EmptyTypes);
            
        // 生成get_Age方法的IL代码
        ILGenerator getAgeIL = getAgeMethod.GetILGenerator();
        getAgeIL.Emit(OpCodes.Ldarg_0); // 加载this
        getAgeIL.Emit(OpCodes.Ldfld, ageField); // 加载_age字段
        getAgeIL.Emit(OpCodes.Ret); // 返回
        
        // 创建Age属性的set方法
        MethodBuilder setAgeMethod = typeBuilder.DefineMethod(
            "set_Age",
            MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
            null,
            new[] { typeof(int) });
            
        // 生成set_Age方法的IL代码
        ILGenerator setAgeIL = setAgeMethod.GetILGenerator();
        
        // 添加验证：年龄必须大于0
        Label validAge = setAgeIL.DefineLabel();
        
        setAgeIL.Emit(OpCodes.Ldarg_1); // 加载参数值
        setAgeIL.Emit(OpCodes.Ldc_I4_0); // 加载0
        setAgeIL.Emit(OpCodes.Bgt, validAge); // 如果参数 > 0，跳转到validAge标签
        
        // 如果年龄 <= 0，抛出异常
        setAgeIL.Emit(OpCodes.Ldstr, "Age must be greater than 0");
        setAgeIL.Emit(OpCodes.Newobj, typeof(ArgumentException).GetConstructor(new[] { typeof(string) }));
        setAgeIL.Emit(OpCodes.Throw);
        
        // 如果年龄有效，设置字段值
        setAgeIL.MarkLabel(validAge);
        setAgeIL.Emit(OpCodes.Ldarg_0); // 加载this
        setAgeIL.Emit(OpCodes.Ldarg_1); // 加载参数值
        setAgeIL.Emit(OpCodes.Stfld, ageField); // 存储到_age字段
        setAgeIL.Emit(OpCodes.Ret); // 返回
        
        // 将get和set方法关联到Age属性
        ageProperty.SetGetMethod(getAgeMethod);
        ageProperty.SetSetMethod(setAgeMethod);
        
        // 创建构造函数
        ConstructorBuilder constructor = typeBuilder.DefineConstructor(
            MethodAttributes.Public,
            CallingConventions.Standard,
            new[] { typeof(string), typeof(int) });
            
        // 生成构造函数的IL代码
        ILGenerator constructorIL = constructor.GetILGenerator();
        
        // 调用基类(System.Object)构造函数
        constructorIL.Emit(OpCodes.Ldarg_0);
        constructorIL.Emit(OpCodes.Call, typeof(object).GetConstructor(Type.EmptyTypes));
        
        // 设置Name属性
        constructorIL.Emit(OpCodes.Ldarg_0);
        constructorIL.Emit(OpCodes.Ldarg_1);
        constructorIL.Emit(OpCodes.Call, setNameMethod);
        
        // 设置Age属性
        constructorIL.Emit(OpCodes.Ldarg_0);
        constructorIL.Emit(OpCodes.Ldarg_2);
        constructorIL.Emit(OpCodes.Call, setAgeMethod);
        
        constructorIL.Emit(OpCodes.Ret);
        
        // 创建GetDescription方法
        MethodBuilder getDescriptionMethod = typeBuilder.DefineMethod(
            "GetDescription",
            MethodAttributes.Public,
            typeof(string),
            Type.EmptyTypes);
            
        // 生成GetDescription方法的IL代码
        ILGenerator getDescIL = getDescriptionMethod.GetILGenerator();
        
        // 创建字符串：$"Person: {Name}, {Age} years old"
        getDescIL.DeclareLocal(typeof(string)); // 声明本地变量存储结果
        
        getDescIL.Emit(OpCodes.Ldstr, "Person: {0}, {1} years old");
        getDescIL.Emit(OpCodes.Ldarg_0);
        getDescIL.Emit(OpCodes.Call, getNameMethod);
        getDescIL.Emit(OpCodes.Ldarg_0);
        getDescIL.Emit(OpCodes.Call, getAgeMethod);
        getDescIL.Emit(OpCodes.Box, typeof(int)); // 装箱int为object
        getDescIL.Emit(OpCodes.Call, typeof(string).GetMethod(
            "Format", new[] { typeof(string), typeof(object), typeof(object) }));
        getDescIL.Emit(OpCodes.Ret);
        
        // 创建类型
        Type personType = typeBuilder.CreateType();
        
        return personType;
    }
}

// 使用动态生成的类型
class Program
{
    static void Main()
    {
        // 创建动态类型
        Type personType = DynamicTypeGenerator.CreatePersonType();
        
        Console.WriteLine($"创建的类型名称: {personType.FullName}");
        Console.WriteLine("属性:");
        foreach (var prop in personType.GetProperties())
        {
            Console.WriteLine($"- {prop.PropertyType.Name} {prop.Name}");
        }
        
        Console.WriteLine("方法:");
        foreach (var method in personType.GetMethods())
        {
            // 只显示自定义方法，不显示继承的方法
            if (method.DeclaringType == personType && !method.IsSpecialName)
            {
                Console.WriteLine($"- {method.ReturnType.Name} {method.Name}()");
            }
        }
        
        // 创建Person实例
        object person = Activator.CreateInstance(personType, "John Doe", 30);
        
        // 获取属性值
        string name = (string)personType.GetProperty("Name").GetValue(person);
        int age = (int)personType.GetProperty("Age").GetValue(person);
        
        Console.WriteLine($"\n通过反射获取属性值: Name = {name}, Age = {age}");
        
        // 调用GetDescription方法
        string description = (string)personType.GetMethod("GetDescription").Invoke(person, null);
        Console.WriteLine($"GetDescription方法结果: {description}");
        
        // 尝试设置无效的年龄
        try
        {
            personType.GetProperty("Age").SetValue(person, -5);
        }
        catch (TargetInvocationException ex)
        {
            Console.WriteLine($"捕获到异常: {ex.InnerException.Message}");
        }
        
        // 动态创建更多Person实例并使用
        for (int i = 1; i <= 3; i++)
        {
            object newPerson = Activator.CreateInstance(personType, $"Person {i}", 20 + i);
            string desc = (string)personType.GetMethod("GetDescription").Invoke(newPerson, null);
            Console.WriteLine(desc);
        }
    }
}
```

**性能比较：动态代码生成 vs 传统反射**

下面的示例比较了不同方法创建和使用对象的性能差异：

```csharp
using System;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Linq.Expressions;

class PerformanceComparison
{
    // 定义常规类作为基准
    public class StaticPerson
    {
        private string _name;
        private int _age;
        
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }
        
        public int Age
        {
            get { return _age; }
            set
            {
                if (value <= 0)
                    throw new ArgumentException("Age must be greater than 0");
                _age = value;
            }
        }
        
        public StaticPerson(string name, int age)
        {
            Name = name;
            Age = age;
        }
        
        public string GetDescription()
        {
            return $"Person: {Name}, {Age} years old";
        }
    }
    
    // 创建动态类型
    private static Type CreateDynamicPersonType()
    {
        // [使用前面的CreatePersonType方法的代码]
        return DynamicTypeGenerator.CreatePersonType();
    }
    
    // 测试直接实例化和方法调用（基准）
    public static void TestDirect(int iterations)
    {
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < iterations; i++)
        {
            var person = new StaticPerson("John", 30);
            string name = person.Name;
            int age = person.Age;
            string description = person.GetDescription();
        }
        
        sw.Stop();
        Console.WriteLine($"直接调用: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试传统反射
    public static void TestReflection(int iterations)
    {
        Type type = typeof(StaticPerson);
        ConstructorInfo ctor = type.GetConstructor(new[] { typeof(string), typeof(int) });
        PropertyInfo nameProperty = type.GetProperty("Name");
        PropertyInfo ageProperty = type.GetProperty("Age");
        MethodInfo getDescMethod = type.GetMethod("GetDescription");
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < iterations; i++)
        {
            object person = ctor.Invoke(new object[] { "John", 30 });
            string name = (string)nameProperty.GetValue(person);
            int age = (int)ageProperty.GetValue(person);
            string description = (string)getDescMethod.Invoke(person, null);
        }
        
        sw.Stop();
        Console.WriteLine($"传统反射: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试缓存反射委托
    public static void TestCachedReflection(int iterations)
    {
        Type type = typeof(StaticPerson);
        ConstructorInfo ctor = type.GetConstructor(new[] { typeof(string), typeof(int) });
        
        // 创建委托
        var createDelegate = new Func<string, int, StaticPerson>((name, age) => 
            (StaticPerson)ctor.Invoke(new object[] { name, age }));
            
        var nameGetDelegate = (Func<StaticPerson, string>)Delegate.CreateDelegate(
            typeof(Func<StaticPerson, string>),
            null,
            type.GetProperty("Name").GetGetMethod());
            
        var ageGetDelegate = (Func<StaticPerson, int>)Delegate.CreateDelegate(
            typeof(Func<StaticPerson, int>),
            null,
            type.GetProperty("Age").GetGetMethod());
            
        var getDescDelegate = (Func<StaticPerson, string>)Delegate.CreateDelegate(
            typeof(Func<StaticPerson, string>),
            null,
            type.GetMethod("GetDescription"));
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < iterations; i++)
        {
            StaticPerson person = createDelegate("John", 30);
            string name = nameGetDelegate(person);
            int age = ageGetDelegate(person);
            string description = getDescDelegate(person);
        }
        
        sw.Stop();
        Console.WriteLine($"缓存反射委托: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试表达式树
    public static void TestExpressionTrees(int iterations)
    {
        Type type = typeof(StaticPerson);
        
        // 构建表达式树创建实例
        ConstructorInfo ctor = type.GetConstructor(new[] { typeof(string), typeof(int) });
        var nameParam = Expression.Parameter(typeof(string), "name");
        var ageParam = Expression.Parameter(typeof(int), "age");
        
        NewExpression newExp = Expression.New(ctor, nameParam, ageParam);
        var createLambda = Expression.Lambda<Func<string, int, StaticPerson>>(
            newExp, nameParam, ageParam);
        var createDelegate = createLambda.Compile();
        
        // 属性和方法委托
        var personParam = Expression.Parameter(typeof(StaticPerson), "person");
        
        var getNameExp = Expression.Property(personParam, "Name");
        var getNameLambda = Expression.Lambda<Func<StaticPerson, string>>(
            getNameExp, personParam);
        var getNameDelegate = getNameLambda.Compile();
        
        var getAgeExp = Expression.Property(personParam, "Age");
        var getAgeLambda = Expression.Lambda<Func<StaticPerson, int>>(
            getAgeExp, personParam);
        var getAgeDelegate = getAgeLambda.Compile();
        
        var getDescExp = Expression.Call(personParam, type.GetMethod("GetDescription"));
        var getDescLambda = Expression.Lambda<Func<StaticPerson, string>>(
            getDescExp, personParam);
        var getDescDelegate = getDescLambda.Compile();
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < iterations; i++)
        {
            StaticPerson person = createDelegate("John", 30);
            string name = getNameDelegate(person);
            int age = getAgeDelegate(person);
            string description = getDescDelegate(person);
        }
        
        sw.Stop();
        Console.WriteLine($"表达式树: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试动态生成类型
    public static void TestDynamicTypeCreation()
    {
        Stopwatch sw = Stopwatch.StartNew();
        Type dynamicType = CreateDynamicPersonType();
        sw.Stop();
        Console.WriteLine($"动态类型生成时间: {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试动态类型实例使用
    public static void TestDynamicTypeUsage(int iterations)
    {
        Type dynamicType = CreateDynamicPersonType();
        
        ConstructorInfo ctor = dynamicType.GetConstructor(new[] { typeof(string), typeof(int) });
        PropertyInfo nameProperty = dynamicType.GetProperty("Name");
        PropertyInfo ageProperty = dynamicType.GetProperty("Age");
        MethodInfo getDescMethod = dynamicType.GetMethod("GetDescription");
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < iterations; i++)
        {
            object person = ctor.Invoke(new object[] { "John", 30 });
            string name = (string)nameProperty.GetValue(person);
            int age = (int)ageProperty.GetValue(person);
            string description = (string)getDescMethod.Invoke(person, null);
        }
        
        sw.Stop();
        Console.WriteLine($"动态类型使用(反射): {sw.ElapsedMilliseconds}ms");
    }
    
    // 测试动态类型 + 缓存委托
    public static void TestDynamicTypeWithDelegate(int iterations)
    {
        Type dynamicType = CreateDynamicPersonType();
        
        // 创建构造函数委托
        ConstructorInfo ctor = dynamicType.GetConstructor(new[] { typeof(string), typeof(int) });
        var dynamicCtor = new Func<string, int, object>((name, age) => 
            ctor.Invoke(new object[] { name, age }));
        
        // 创建属性和方法委托
        var nameGetMethod = dynamicType.GetProperty("Name").GetGetMethod();
        var ageGetMethod = dynamicType.GetProperty("Age").GetGetMethod();
        var getDescMethod = dynamicType.GetMethod("GetDescription");
        
        var nameGetDelegate = (Func<object, string>)Delegate.CreateDelegate(
            typeof(Func<object, string>),
            null,
            nameGetMethod);
            
        var ageGetDelegate = (Func<object, int>)Delegate.CreateDelegate(
            typeof(Func<object, int>),
            null,
            ageGetMethod);
            
        var getDescDelegate = (Func<object, string>)Delegate.CreateDelegate(
            typeof(Func<object, string>),
            null,
            getDescMethod);
        
        Stopwatch sw = Stopwatch.StartNew();
        
        for (int i = 0; i < iterations; i++)
        {
            object person = dynamicCtor("John", 30);
            string name = nameGetDelegate(person);
            int age = ageGetDelegate(person);
            string description = getDescDelegate(person);
        }
        
        sw.Stop();
        Console.WriteLine($"动态类型 + 委托: {sw.ElapsedMilliseconds}ms");
    }
    
    // 运行所有测试
    public static void RunAllTests()
    {
        int iterations = 1_000_000;
        Console.WriteLine($"执行每种方法 {iterations:N0} 次:\n");
        
        TestDynamicTypeCreation();
        Console.WriteLine();
        
        TestDirect(iterations);
        TestReflection(iterations);
        TestCachedReflection(iterations);
        TestExpressionTrees(iterations);
        TestDynamicTypeUsage(iterations);
        TestDynamicTypeWithDelegate(iterations);
    }
}
```

**性能比较结果（示例）：**

动态类型生成时间: 约50-150ms（一次性成本）

对于1,000,000次操作：
- 直接调用: 约10-20ms
- 传统反射: 约800-1200ms
- 缓存反射委托: 约30-50ms
- 表达式树: 约40-60ms
- 动态类型使用(反射): 约800-1200ms
- 动态类型 + 委托: 约30-50ms

**动态代码生成与传统反射的比较：**

|                | 动态代码生成                 | 传统反射                 |
| -------------- | ---------------------------- | ------------------------ |
| **初始化成本** | 高（需要生成IL代码）         | 低（直接使用现有类型）   |
| **运行时性能** | 与直接调用接近（使用委托）   | 较慢（每次操作都有开销） |
| **灵活性**     | 可以创建全新类型             | 只能使用已有类型         |
| **复杂度**     | 高（需要了解IL）             | 低（API较简单）          |
| **调试难度**   | 高（动态生成的代码难以调试） | 中等                     |
| **场景**       | 性能关键型应用、代码生成     | 简单动态行为、配置驱动   |

**动态代码生成的应用场景：**

1. **高性能动态代理**：创建轻量级的AOP代理
2. **ORM框架**：生成高效的数据访问代码
3. **代码生成工具**：根据模板生成代码
4. **动态类型系统**：创建运行时定义的类型
5. **即时编译(JIT)优化**：自定义JIT编译器
6. **领域特定语言(DSL)**：为DSL创建自定义执行引擎
7. **插件架构**：创建高性能插件系统

**传统反射的应用场景：**

1. **配置驱动的应用程序**：根据配置动态调用方法
2. **依赖注入容器**：解析和创建依赖关系
3. **序列化/反序列化**：读取和写入对象数据
4. **单元测试**：访问私有成员进行测试
5. **简单的插件系统**：加载和调用插件
6. **数据绑定**：将数据绑定到UI元素

**最佳实践与建议：**

1. **选择合适的工具**：
   - 单次或低频操作：使用传统反射
   - 高频操作：使用缓存的反射委托或表达式树
   - 需要创建新类型：使用动态代码生成

2. **动态代码生成注意事项**：
   - 谨慎处理IL生成，错误的IL可能导致运行时崩溃
   - 考虑一次生成、多次使用的模式
   - 为复杂操作创建辅助方法
   - 实现适当的错误处理

3. **性能优化**：
   - 缓存生成的类型和委托
   - 减少动态生成的频率
   - 使用工具和库（如Expression、Castle DynamicProxy）

4. **可维护性**：
   - 隔离动态代码生成逻辑
   - 提供足够的文档和注释
   - 考虑使用更高级的抽象，如表达式树

**优点分析：**
- 动态代码生成允许在运行时创建高效的代码
- 生成后的代码接近原生性能
- 提供传统反射无法实现的灵活性
- 支持高级场景，如方法拦截和代理

**缺点分析：**
- 学习曲线陡峭，需要了解IL
- 调试困难，错误难以定位
- 初始化成本高
- 代码可读性和可维护性降低
- 可能引入安全风险

## 四、综合应用案例

### 技术题10：自定义依赖注入容器

**问题：** 使用反射和元数据设计并实现一个简单的依赖注入(DI)容器，支持构造函数注入、属性注入，以及生命周期管理（单例、瞬态）。提供使用示例并分析其工作原理和限制。

**答案：**

**依赖注入容器的设计与实现：**

下面我们将实现一个简单但功能完整的依赖注入容器，它支持：
- 类型注册与解析
- 构造函数注入
- 属性注入
- 生命周期管理（单例、瞬态）
- 基于接口的服务注册

```csharp
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

// 自定义特性，用于标记需要注入的属性
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class InjectAttribute : Attribute
{
}

// 依赖注入容器
public class DIContainer
{
    // 服务生命周期枚举
    public enum Lifestyle
    {
        Singleton, // 单例
        Transient  // 瞬态
    }
    
    // 服务注册信息类
    private class ServiceRegistration
    {
        public Type ServiceType { get; set; }
        public Type ImplementationType { get; set; }
        public Lifestyle Lifestyle { get; set; }
        public object Instance { get; set; }
        public Func<DIContainer, object> Factory { get; set; }
    }
    
    // 服务注册表
    private readonly Dictionary<Type, ServiceRegistration> _registrations = new Dictionary<Type, ServiceRegistration>();
    
    // 用于并发解析的锁对象
    private readonly ConcurrentDictionary<Type, object> _resolutionLocks = new ConcurrentDictionary<Type, object>();
    
    // 当前正在解析的类型堆栈（用于检测循环依赖）
    private readonly ThreadLocal<Stack<Type>> _resolutionStack = new ThreadLocal<Stack<Type>>(() => new Stack<Type>());
    
    #region 服务注册方法
    
    // 注册瞬态服务
    public DIContainer RegisterTransient<TService, TImplementation>()
        where TImplementation : TService
    {
        return Register<TService, TImplementation>(Lifestyle.Transient);
    }
    
    // 直接注册瞬态实现类型
    public DIContainer RegisterTransient<TService>()
    {
        return Register<TService, TService>(Lifestyle.Transient);
    }
    
    // 注册单例服务
    public DIContainer RegisterSingleton<TService, TImplementation>()
        where TImplementation : TService
    {
        return Register<TService, TImplementation>(Lifestyle.Singleton);
    }
    
    // 直接注册单例实现类型
    public DIContainer RegisterSingleton<TService>()
    {
        return Register<TService, TService>(Lifestyle.Singleton);
    }
    
    // 注册现有实例作为单例
    public DIContainer RegisterInstance<TService>(TService instance)
    {
        if (instance == null)
            throw new ArgumentNullException(nameof(instance));
            
        Type serviceType = typeof(TService);
        
        _registrations[serviceType] = new ServiceRegistration
        {
            ServiceType = serviceType,
            ImplementationType = instance.GetType(),
            Lifestyle = Lifestyle.Singleton,
            Instance = instance
        };
        
        return this;
    }
    
    // 注册工厂方法
    public DIContainer RegisterFactory<TService>(Func<DIContainer, TService> factory, Lifestyle lifestyle = Lifestyle.Transient)
    {
        if (factory == null)
            throw new ArgumentNullException(nameof(factory));
            
        Type serviceType = typeof(TService);
        
        _registrations[serviceType] = new ServiceRegistration
        {
            ServiceType = serviceType,
            ImplementationType = null,
            Lifestyle = lifestyle,
            Factory = c => factory(c)
        };
        
        return this;
    }
    
    // 基本注册方法
    private DIContainer Register<TService, TImplementation>(Lifestyle lifestyle)
    {
        Type serviceType = typeof(TService);
        Type implementationType = typeof(TImplementation);
        
        if (!serviceType.IsAssignableFrom(implementationType))
            throw new ArgumentException($"{implementationType} 不实现 {serviceType}");
            
        _registrations[serviceType] = new ServiceRegistration
        {
            ServiceType = serviceType,
            ImplementationType = implementationType,
            Lifestyle = lifestyle,
            Instance = null
        };
        
        return this;
    }
    
    #endregion
    
    #region 服务解析方法
    
    // 解析服务
    public TService Resolve<TService>()
    {
        return (TService)Resolve(typeof(TService));
    }
    
    // 解析服务（非泛型版本）
    public object Resolve(Type serviceType)
    {
        if (serviceType == null)
            throw new ArgumentNullException(nameof(serviceType));
            
        // 检查循环依赖
        if (_resolutionStack.Value.Contains(serviceType))
        {
            string dependencyChain = string.Join(" -> ", _resolutionStack.Value.Reverse()) + " -> " + serviceType.Name;
            throw new InvalidOperationException($"检测到循环依赖: {dependencyChain}");
        }
        
        // 查找注册信息
        if (!_registrations.TryGetValue(serviceType, out ServiceRegistration registration))
        {
            // 如果服务没有注册但是具体类型（非接口或抽象类），尝试直接创建它
            if (!serviceType.IsInterface && !serviceType.IsAbstract)
            {
                return CreateInstance(serviceType);
            }
            
            throw new InvalidOperationException($"未注册服务: {serviceType.Name}");
        }
        
        _resolutionStack.Value.Push(serviceType);
        
        try
        {
            return ResolveRegistration(registration);
        }
        finally
        {
            _resolutionStack.Value.Pop();
        }
    }
    
    // 解析注册信息
    private object ResolveRegistration(ServiceRegistration registration)
    {
        // 如果已有实例且是单例，直接返回
        if (registration.Instance != null)
            return registration.Instance;
            
        // 如果有工厂方法，使用工厂创建实例
        if (registration.Factory != null)
        {
            object instance = registration.Factory(this);
            
            // 如果是单例，保存实例
            if (registration.Lifestyle == Lifestyle.Singleton)
                registration.Instance = instance;
                
            return instance;
        }
        
        // 创建实例
        if (registration.Lifestyle == Lifestyle.Singleton)
        {
            // 使用双重检查锁定模式确保线程安全
            if (registration.Instance == null)
            {
                // 为每个类型获取对应的锁对象
                object lockObj = _resolutionLocks.GetOrAdd(registration.ServiceType, _ => new object());
                
                lock (lockObj)
                {
                    if (registration.Instance == null)
                    {
                        registration.Instance = CreateInstance(registration.ImplementationType);
                    }
                }
            }
            
            return registration.Instance;
        }
        else // Transient
        {
            return CreateInstance(registration.ImplementationType);
        }
    }
    
    // 创建实例
    private object CreateInstance(Type type)
    {
        // 获取所有构造函数
        ConstructorInfo[] constructors = type.GetConstructors();
        
        if (constructors.Length == 0)
        {
            // 如果没有公共构造函数，尝试使用默认构造函数
            return Activator.CreateInstance(type);
        }
        
        // 选择最合适的构造函数（优先选择有参数但可以解析所有参数的构造函数）
        ConstructorInfo constructor = GetBestConstructor(constructors);
        
        if (constructor == null)
        {
            throw new InvalidOperationException($"无法找到合适的构造函数: {type.Name}");
        }
        
        // 解析构造函数参数
        ParameterInfo[] parameters = constructor.GetParameters();
        object[] parameterValues = new object[parameters.Length];
        
        for (int i = 0; i < parameters.Length; i++)
        {
            Type parameterType = parameters[i].ParameterType;
            
            try
            {
                parameterValues[i] = Resolve(parameterType);
            }
            catch (InvalidOperationException ex)
            {
                throw new InvalidOperationException($"无法解析类型 {type.Name} 的构造函数参数 {parameters[i].Name}: {ex.Message}", ex);
            }
        }
        
        // 创建实例
        object instance = constructor.Invoke(parameterValues);
        
        // 执行属性注入
        InjectProperties(instance);
        
        return instance;
    }
    
    // 选择最佳构造函数
    private ConstructorInfo GetBestConstructor(ConstructorInfo[] constructors)
    {
        // 按参数数量降序排序
        Array.Sort(constructors, (c1, c2) => c2.GetParameters().Length.CompareTo(c1.GetParameters().Length));
        
        foreach (var constructor in constructors)
        {
            ParameterInfo[] parameters = constructor.GetParameters();
            bool canResolveAll = true;
            
            foreach (var parameter in parameters)
            {
                Type parameterType = parameter.ParameterType;
                
                // 检查是否已注册或是可以直接创建的类型
                if (!_registrations.ContainsKey(parameterType) && 
                    (parameterType.IsInterface || parameterType.IsAbstract))
                {
                    canResolveAll = false;
                    break;
                }
            }
            
            if (canResolveAll)
                return constructor;
        }
        
        // 如果没有找到合适的构造函数，返回无参构造函数
        return constructors.FirstOrDefault(c => c.GetParameters().Length == 0);
    }
    
    // 属性注入
    private void InjectProperties(object instance)
    {
        Type type = instance.GetType();
        
        // 获取所有带有Inject特性的属性
        var properties = type.GetProperties()
            .Where(p => p.CanWrite && p.GetCustomAttribute<InjectAttribute>() != null);
            
        foreach (var property in properties)
        {
            Type propertyType = property.PropertyType;
            
            try
            {
                // 解析属性值
                object value = Resolve(propertyType);
                
                // 设置属性
                property.SetValue(instance, value);
            }
            catch (InvalidOperationException ex)
            {
                // 记录警告但不阻止创建
                Console.WriteLine($"警告: 无法注入属性 {property.Name} 到 {type.Name}: {ex.Message}");
            }
        }
    }
    
    #endregion
    
    // 检查服务是否已注册
    public bool IsRegistered<TService>()
    {
        return IsRegistered(typeof(TService));
    }
    
    // 检查服务是否已注册（非泛型版本）
    public bool IsRegistered(Type serviceType)
    {
        return _registrations.ContainsKey(serviceType);
    }
}

// 示例接口和类
public interface ILogger
{
    void Log(string message);
}

public class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
}

public interface IUserRepository
{
    User GetById(int id);
}

public class SqlUserRepository : IUserRepository
{
    private readonly ILogger _logger;
    
    public SqlUserRepository(ILogger logger)
    {
        _logger = logger;
    }
    
    public User GetById(int id)
    {
        _logger.Log($"Getting user with ID: {id}");
        return new User { Id = id, Name = "User " + id };
    }
}

public interface IUserService
{
    User GetUser(int id);
}

public class UserService : IUserService
{
    private readonly IUserRepository _repository;
    
    [Inject]
    public ILogger Logger { get; set; }
    
    public UserService(IUserRepository repository)
    {
        _repository = repository;
    }
    
    public User GetUser(int id)
    {
        Logger?.Log($"UserService.GetUser({id}) called");
        return _repository.GetById(id);
    }
}

public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}

// 循环依赖示例
public interface IServiceA
{
    void DoSomething();
}

public interface IServiceB
{
    void DoSomething();
}

public class ServiceA : IServiceA
{
    private readonly IServiceB _serviceB;
    
    public ServiceA(IServiceB serviceB)
    {
        _serviceB = serviceB;
    }
    
    public void DoSomething()
    {
        Console.WriteLine("ServiceA doing something");
    }
}

public class ServiceB : IServiceB
{
    private readonly IServiceA _serviceA;
    
    public ServiceB(IServiceA serviceA)
    {
        _serviceA = serviceA;
    }
    
    public void DoSomething()
    {
        Console.WriteLine("ServiceB doing something");
    }
}

// 使用依赖注入容器
class Program
{
    static void Main()
    {
        // 创建容器
        var container = new DIContainer();
        
        // 注册服务
        container.RegisterSingleton<ILogger, ConsoleLogger>();
        container.RegisterTransient<IUserRepository, SqlUserRepository>();
        container.RegisterTransient<IUserService, UserService>();
        
        // 解析服务
        IUserService userService = container.Resolve<IUserService>();
        
        // 使用服务
        User user = userService.GetUser(1);
        Console.WriteLine($"Found user: {user.Name}");
        
        // 演示单例行为
        ILogger logger1 = container.Resolve<ILogger>();
        ILogger logger2 = container.Resolve<ILogger>();
        
        Console.WriteLine($"Singleton test: Same instance? {ReferenceEquals(logger1, logger2)}");
        
        // 演示瞬态行为
        IUserRepository repo1 = container.Resolve<IUserRepository>();
        IUserRepository repo2 = container.Resolve<IUserRepository>();
        
        Console.WriteLine($"Transient test: Same instance? {ReferenceEquals(repo1, repo2)}");
        
        // 演示工厂注册
        container.RegisterFactory<string>(c => "Factory created string", DIContainer.Lifestyle.Singleton);
        string value = container.Resolve<string>();
        Console.WriteLine($"Factory test: {value}");
        
        // 演示实例注册
        var customLogger = new ConsoleLogger();
        container.RegisterInstance<ILogger>(customLogger);
        ILogger resolvedLogger = container.Resolve<ILogger>();
        
        Console.WriteLine($"Instance registration test: Same instance? {ReferenceEquals(customLogger, resolvedLogger)}");
        
        // 演示未注册服务的解析
        try
        {
            var notRegistered = container.Resolve<IDisposable>();
        }
        catch (InvalidOperationException ex)
        {
            Console.WriteLine($"Expected error: {ex.Message}");
        }
        
        // 演示循环依赖检测
        var circularContainer = new DIContainer();
        circularContainer.RegisterTransient<IServiceA, ServiceA>();
        circularContainer.RegisterTransient<IServiceB, ServiceB>();
        
        try
        {
            var serviceA = circularContainer.Resolve<IServiceA>();
        }
        catch (InvalidOperationException ex)
        {
            Console.WriteLine($"循环依赖检测: {ex.Message}");
        }
    }
}
```

**依赖注入容器工作原理分析：**

**1. 服务注册：**

   当调用`RegisterTransient<T>()`或`RegisterSingleton<T>()`等方法时，容器会将服务类型和实现类型的映射存储在内部字典中，同时记录生命周期(单例/瞬态)信息。

**2. 服务解析过程：**

   a. 从注册表中查找服务类型对应的注册信息
   b. 对于单例服务，检查是否已有实例，如有则返回
   c. 对于瞬态服务或首次访问的单例，创建新实例
   d. 创建实例时，使用反射选择最合适的构造函数
   e. 递归解析构造函数的所有参数
   f. 实例化对象后，查找有`[Inject]`特性标记的属性并注入
   g. 对于单例服务，缓存实例供后续使用

**3. 构造函数选择逻辑：**

   容器优先选择可满足的最大参数数量的构造函数。"可满足"意味着构造函数所有参数类型都已注册或可直接创建。

**4. 循环依赖检测：**

   容器在解析过程中维护一个当前解析路径的堆栈。如果发现正在解析的类型已经在堆栈中（即形成循环），则抛出异常。

**5. 线程安全：**

   单例创建过程使用双重检查锁定模式确保在多线程环境中每个单例只创建一次。

**依赖注入容器的优缺点：**

**优点：**

1. **解耦**：服务使用者不需要了解依赖的具体实现
2. **可测试性**：依赖可以轻松替换为模拟对象
3. **灵活配置**：可以在运行时更改服务实现
4. **生命周期管理**：自动管理对象创建和共享
5. **关注点分离**：服务不需要关心依赖的创建过程

**缺点：**

1. **性能开销**：使用反射创建对象和注入依赖比直接创建慢
2. **可读性降低**：依赖关系可能不那么直观
3. **过度使用风险**：可能导致不必要的复杂性
4. **潜在运行时错误**：依赖解析可能在运行时失败
5. **启动时间延长**：需要解析和创建对象图

**我们实现的DI容器的限制：**

1. **有限的生命周期**：只支持单例和瞬态，没有作用域(Scoped)支持
2. **无拦截器**：不支持AOP风格的方法拦截
3. **简单的循环依赖处理**：只能检测但不能解决循环依赖
4. **有限的基于特性的配置**：只支持基本的`[Inject]`特性
5. **没有惰性初始化选项**：不能延迟创建服务
6. **缺少释放机制**：没有实现IDisposable的对象处理
7. **有限的注册API**：缺乏按程序集扫描等高级功能

**与商业DI容器的比较：**

与成熟的依赖注入容器（如Microsoft.Extensions.DependencyInjection、Autofac或Unity）相比，我们的实现更简单，功能更有限。商业容器通常提供：

- 更多的生命周期选项（如作用域、每请求）
- 更丰富的注册API（如按约定注册、按程序集扫描）
- 拦截器和代理支持
- 高级解析功能（如延迟解析、集合解析）
- 性能优化（如表达式树编译）
- 适当的资源释放（IDisposable支持）

**实际应用建议：**

1. **生产环境使用成熟容器**：如Microsoft.Extensions.DependencyInjection或Autofac
2. **了解注册方式的影响**：合理选择瞬态和单例等生命周期
3. **避免不必要的服务定位器模式**：优先使用构造函数注入
4. **保持依赖简单**：避免复杂的依赖图和循环依赖
5. **适度使用属性注入**：仅对可选依赖使用属性注入
6. **明确服务职责**：遵循单一职责原则，避免服务成为"上帝对象"

**扩展思路：**

自定义依赖注入容器可以扩展以支持：

1. **作用域生命周期**：添加类似请求作用域的概念
2. **拦截器支持**：使用代理实现AOP功能
3. **条件注册**：基于条件选择不同实现
4. **集合支持**：注册和解析同一接口的多个实现
5. **参数注入**：支持向服务传递自定义参数
6. **惰性初始化**：使用代理延迟创建实际服务
7. **更好的性能**：使用表达式树编译或IL生成